
// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © ZoeUdokpan
////

//@version=5
indicator(title='spot sp.6', overlay=false , max_labels_count = 500 )

w = input(defval = 0,title = "W",group="Increase for density")


src = input(close)
c_l_o_s_e = src
o_p_e_n = c_l_o_s_e[1]
h_i_g_h = math.max(c_l_o_s_e,c_l_o_s_e[1])
l_o_w = math.min(c_l_o_s_e,c_l_o_s_e[1])
v_o_l_u_m_e = volume

base_count = 0
length = 14

sig = 0

timeframe = input.timeframe ( "1" , "Input h_i_g_her Resolution" )
[atr14,atr1,
 _open,
 _high,_high1,_high2,_high3,_high4,_high5,_high6,
 _low,_low1,_low2,_low3,_low4,_low5,_low6,
 _close,_close1,_close2,_close3,_close4,_close5,_close6,_close7,
 C_BodyHi,C_BodyHi1,C_BodyHi2,C_BodyHi3,C_BodyHi4, C_BodyHi5,C_BodyHi6,C_BodyHi7,
 C_BodyLo,C_BodyLo1,C_BodyLo2,C_BodyLo3,C_BodyLo4, C_BodyLo5,C_BodyLo6,C_BodyLo7,
 C_Body,C_BodyAvg,C_Body_legout,
 legout_green,legout_green_1,
 legout_red,legout_red_1,
 base,not_base_1,not_base_2,not_base_3,not_base_4,not_base_5,not_base_6,not_base_7,not_base_8,not_base_9,not_base_10,not_base_11,not_base_12,not_base_13]=
 request.security ( syminfo.ticker , timeframe ,
 [ta.ema(h_i_g_h-l_o_w, length),
 ta.ema(h_i_g_h-l_o_w, 1),
 o_p_e_n,
 h_i_g_h,
 h_i_g_h[1],
 h_i_g_h[2],
 h_i_g_h[3],
 h_i_g_h[4],
 h_i_g_h[5],
 h_i_g_h[6],
 l_o_w,
 l_o_w[1],
 l_o_w[2],
 l_o_w[3],
 l_o_w[4],
 l_o_w[5],
 l_o_w[6],
 c_l_o_s_e,
 c_l_o_s_e[1],
 c_l_o_s_e[2],
 c_l_o_s_e[3],
 c_l_o_s_e[4],
 c_l_o_s_e[5],
 c_l_o_s_e[6],
 c_l_o_s_e[7],
 math.max(c_l_o_s_e, o_p_e_n),
 math.max(c_l_o_s_e, o_p_e_n)[1],
 math.max(c_l_o_s_e, o_p_e_n)[2],
 math.max(c_l_o_s_e, o_p_e_n)[3],
 math.max(c_l_o_s_e, o_p_e_n)[4],
 math.max(c_l_o_s_e, o_p_e_n)[5],
 math.max(c_l_o_s_e, o_p_e_n)[6],
 math.max(c_l_o_s_e, o_p_e_n)[7],
 math.min(c_l_o_s_e, o_p_e_n),
 math.min(c_l_o_s_e, o_p_e_n)[1],
 math.min(c_l_o_s_e, o_p_e_n)[2],
 math.min(c_l_o_s_e, o_p_e_n)[3],
 math.min(c_l_o_s_e, o_p_e_n)[4],
 math.min(c_l_o_s_e, o_p_e_n)[5],
 math.min(c_l_o_s_e, o_p_e_n)[6],
 math.min(c_l_o_s_e, o_p_e_n)[7],
 (math.max(c_l_o_s_e, o_p_e_n) - math.min(c_l_o_s_e, o_p_e_n)),
 ta.ema((math.max(c_l_o_s_e, o_p_e_n) - math.min(c_l_o_s_e, o_p_e_n)), length),
 math.abs(c_l_o_s_e-c_l_o_s_e[1]),
 (ta.ema(h_i_g_h-l_o_w, 1) >= ta.ema(h_i_g_h-l_o_w, length) and ta.ema((math.max(c_l_o_s_e, o_p_e_n) - math.min(c_l_o_s_e, o_p_e_n)), 1) >= ta.ema((math.max(c_l_o_s_e, o_p_e_n) - math.min(c_l_o_s_e, o_p_e_n)), length) and o_p_e_n < c_l_o_s_e and math.abs(c_l_o_s_e-c_l_o_s_e[1])/math.max(h_i_g_h - l_o_w, math.abs(h_i_g_h - c_l_o_s_e[1]), math.abs(l_o_w - c_l_o_s_e[1])) > 0.50),
 (ta.ema(h_i_g_h-l_o_w, 1) >= ta.ema(h_i_g_h-l_o_w, length) and ta.ema((math.max(c_l_o_s_e, o_p_e_n) - math.min(c_l_o_s_e, o_p_e_n)), 1) >= ta.ema((math.max(c_l_o_s_e, o_p_e_n) - math.min(c_l_o_s_e, o_p_e_n)), length) and o_p_e_n < c_l_o_s_e and math.abs(c_l_o_s_e-c_l_o_s_e[1])/math.max(h_i_g_h - l_o_w, math.abs(h_i_g_h - c_l_o_s_e[1]), math.abs(l_o_w - c_l_o_s_e[1])) > 0.50)[1],
 (ta.ema(h_i_g_h-l_o_w, 1) >= ta.ema(h_i_g_h-l_o_w, length) and ta.ema((math.max(c_l_o_s_e, o_p_e_n) - math.min(c_l_o_s_e, o_p_e_n)), 1) >= ta.ema((math.max(c_l_o_s_e, o_p_e_n) - math.min(c_l_o_s_e, o_p_e_n)), length) and o_p_e_n > c_l_o_s_e and math.abs(c_l_o_s_e-c_l_o_s_e[1])/math.max(h_i_g_h - l_o_w, math.abs(h_i_g_h - c_l_o_s_e[1]), math.abs(l_o_w - c_l_o_s_e[1])) > 0.50) ,
 (ta.ema(h_i_g_h-l_o_w, 1) >= ta.ema(h_i_g_h-l_o_w, length) and ta.ema((math.max(c_l_o_s_e, o_p_e_n) - math.min(c_l_o_s_e, o_p_e_n)), 1) >= ta.ema((math.max(c_l_o_s_e, o_p_e_n) - math.min(c_l_o_s_e, o_p_e_n)), length) and o_p_e_n > c_l_o_s_e and math.abs(c_l_o_s_e-c_l_o_s_e[1])/math.max(h_i_g_h - l_o_w, math.abs(h_i_g_h - c_l_o_s_e[1]), math.abs(l_o_w - c_l_o_s_e[1])) > 0.50)[1] ,
 (ta.ema(h_i_g_h-l_o_w, 1) < ta.ema(h_i_g_h-l_o_w, length) and ta.ema((math.max(c_l_o_s_e, o_p_e_n) - math.min(c_l_o_s_e, o_p_e_n)), 1) < ta.ema((math.max(c_l_o_s_e, o_p_e_n) - math.min(c_l_o_s_e, o_p_e_n)), length) ),
 not ((ta.ema(h_i_g_h-l_o_w, 1) < ta.ema(h_i_g_h-l_o_w, length) and ta.ema((math.max(c_l_o_s_e, o_p_e_n) - math.min(c_l_o_s_e, o_p_e_n)), 1) < ta.ema((math.max(c_l_o_s_e, o_p_e_n) - math.min(c_l_o_s_e, o_p_e_n)), length) ))[1],
 not ((ta.ema(h_i_g_h-l_o_w, 1) < ta.ema(h_i_g_h-l_o_w, length) and ta.ema((math.max(c_l_o_s_e, o_p_e_n) - math.min(c_l_o_s_e, o_p_e_n)), 1) < ta.ema((math.max(c_l_o_s_e, o_p_e_n) - math.min(c_l_o_s_e, o_p_e_n)), length) ))[2] ,
 not ((ta.ema(h_i_g_h-l_o_w, 1) < ta.ema(h_i_g_h-l_o_w, length) and ta.ema((math.max(c_l_o_s_e, o_p_e_n) - math.min(c_l_o_s_e, o_p_e_n)), 1) < ta.ema((math.max(c_l_o_s_e, o_p_e_n) - math.min(c_l_o_s_e, o_p_e_n)), length) ))[3],
 not ((ta.ema(h_i_g_h-l_o_w, 1) < ta.ema(h_i_g_h-l_o_w, length) and ta.ema((math.max(c_l_o_s_e, o_p_e_n) - math.min(c_l_o_s_e, o_p_e_n)), 1) < ta.ema((math.max(c_l_o_s_e, o_p_e_n) - math.min(c_l_o_s_e, o_p_e_n)), length) ))[4],
 not ((ta.ema(h_i_g_h-l_o_w, 1) < ta.ema(h_i_g_h-l_o_w, length) and ta.ema((math.max(c_l_o_s_e, o_p_e_n) - math.min(c_l_o_s_e, o_p_e_n)), 1) < ta.ema((math.max(c_l_o_s_e, o_p_e_n) - math.min(c_l_o_s_e, o_p_e_n)), length) ))[5] ,
 not ((ta.ema(h_i_g_h-l_o_w, 1) < ta.ema(h_i_g_h-l_o_w, length) and ta.ema((math.max(c_l_o_s_e, o_p_e_n) - math.min(c_l_o_s_e, o_p_e_n)), 1) < ta.ema((math.max(c_l_o_s_e, o_p_e_n) - math.min(c_l_o_s_e, o_p_e_n)), length) ))[6] ,
 not ((ta.ema(h_i_g_h-l_o_w, 1) < ta.ema(h_i_g_h-l_o_w, length) and ta.ema((math.max(c_l_o_s_e, o_p_e_n) - math.min(c_l_o_s_e, o_p_e_n)), 1) < ta.ema((math.max(c_l_o_s_e, o_p_e_n) - math.min(c_l_o_s_e, o_p_e_n)), length) ))[7] ,
 not ((ta.ema(h_i_g_h-l_o_w, 1) < ta.ema(h_i_g_h-l_o_w, length) and ta.ema((math.max(c_l_o_s_e, o_p_e_n) - math.min(c_l_o_s_e, o_p_e_n)), 1) < ta.ema((math.max(c_l_o_s_e, o_p_e_n) - math.min(c_l_o_s_e, o_p_e_n)), length) ))[8] ,
 not ((ta.ema(h_i_g_h-l_o_w, 1) < ta.ema(h_i_g_h-l_o_w, length) and ta.ema((math.max(c_l_o_s_e, o_p_e_n) - math.min(c_l_o_s_e, o_p_e_n)), 1) < ta.ema((math.max(c_l_o_s_e, o_p_e_n) - math.min(c_l_o_s_e, o_p_e_n)), length) ))[9],
 not ((ta.ema(h_i_g_h-l_o_w, 1) < ta.ema(h_i_g_h-l_o_w, length) and ta.ema((math.max(c_l_o_s_e, o_p_e_n) - math.min(c_l_o_s_e, o_p_e_n)), 1) < ta.ema((math.max(c_l_o_s_e, o_p_e_n) - math.min(c_l_o_s_e, o_p_e_n)), length) ))[10],
 not ((ta.ema(h_i_g_h-l_o_w, 1) < ta.ema(h_i_g_h-l_o_w, length) and ta.ema((math.max(c_l_o_s_e, o_p_e_n) - math.min(c_l_o_s_e, o_p_e_n)), 1) < ta.ema((math.max(c_l_o_s_e, o_p_e_n) - math.min(c_l_o_s_e, o_p_e_n)), length) ))[11] ,
 not ((ta.ema(h_i_g_h-l_o_w, 1) < ta.ema(h_i_g_h-l_o_w, length) and ta.ema((math.max(c_l_o_s_e, o_p_e_n) - math.min(c_l_o_s_e, o_p_e_n)), 1) < ta.ema((math.max(c_l_o_s_e, o_p_e_n) - math.min(c_l_o_s_e, o_p_e_n)), length) ))[12] ,
 not ((ta.ema(h_i_g_h-l_o_w, 1) < ta.ema(h_i_g_h-l_o_w, length) and ta.ema((math.max(c_l_o_s_e, o_p_e_n) - math.min(c_l_o_s_e, o_p_e_n)), 1) < ta.ema((math.max(c_l_o_s_e, o_p_e_n) - math.min(c_l_o_s_e, o_p_e_n)), length) ))[13]] )


normal_green = (not legout_green and not legout_red and not base and _close >= _close1 )
normal_red = (not legout_green and not legout_red and not base and _close < _close1)
//barcolor( legout_green ? color.black : na )
//barcolor( legout_red   ? color.black : na )
//barcolor( not_base_1 ? color.black : na )




var array_new_box2 = array.new_box()

var int dbr = 1
var int rbd = 1



if legout_green and not legout_green_1 and  ( timeframe.period != timeframe ? not legout_green[1] : 1 )
    if not_base_1
        dbr := 1
    else if not_base_2
        dbr := 2
    else if not_base_3
        dbr := 3
    else if not_base_4
        dbr := 4
    else if not_base_5
        dbr := 5
    else if not_base_6
        dbr := 6
    else if not_base_7
        dbr := 7

       
    if _close >=  ( dbr == 1 ? _close1 : dbr == 2 ? _close2 : dbr == 3 ? _close3 : dbr == 4 ? _close4 : dbr == 5 ? _close5 :  dbr == 6 ? _close6 : _close7 ) and C_Body_legout >=  ( dbr == 1 ? (C_BodyHi1-C_BodyLo1) : dbr == 2 ? (C_BodyHi2-C_BodyLo2) : dbr == 3 ? (C_BodyHi3-C_BodyLo3) : dbr == 4 ? (C_BodyHi4-C_BodyLo4) : dbr == 5 ? (C_BodyHi5-C_BodyLo5) :  dbr == 6 ? (C_BodyHi6-C_BodyLo6) : (C_BodyHi7-C_BodyLo7) ) and dbr >= base_count+1
        sig := 1
       


if legout_red and not legout_red_1 and   ( timeframe.period != timeframe ? not legout_red[1] : 1 )
    if not_base_1
        rbd := 1
    else if not_base_2
        rbd := 2
    else if not_base_3
        rbd := 3
    else if not_base_4
        rbd := 4
    else if not_base_5
        rbd := 5
    else if not_base_6
        rbd := 6
    else if not_base_7
        rbd := 7  

   
    if _close <=  ( rbd == 1 ? _close1 : rbd == 2 ? _close2 : rbd == 3 ? _close3 : rbd == 4 ? _close4 : rbd == 5 ? _close5 : rbd == 6 ? _close6 : _close7 ) and  C_Body_legout >=  ( dbr == 1 ? (C_BodyHi1-C_BodyLo1) : dbr == 2 ? (C_BodyHi2-C_BodyLo2) : dbr == 3 ? (C_BodyHi3-C_BodyLo3) : dbr == 4 ? (C_BodyHi4-C_BodyLo4) : dbr == 5 ? (C_BodyHi5-C_BodyLo5) :  dbr == 6 ? (C_BodyHi6-C_BodyLo6) : (C_BodyHi7-C_BodyLo7) )  and rbd >= base_count+1
        sig := -1
   

//-----------------------ZIG ZAG CODE
add_to_array(arr, val, maxItems) =>
    array.insert(arr, 0, val)
    if array.size(arr) > maxItems
        array.pop(arr)

pivots(length, highSource=high, lowSource = low) =>
    float phigh = ta.highestbars(highSource, length) == 0 ? highSource : na
    float plow = ta.lowestbars(lowSource, length) == 0 ? lowSource : na
    [phigh, plow, bar_index, bar_index]

getSentiment(pDir, oDir, sDir) =>
    sentiment = pDir == oDir ? sDir == pDir or sDir * 2 == -pDir ? -sDir : sDir * 4 : sDir == pDir or sDir == -oDir ? 0 : (math.abs(oDir) > math.abs(pDir) ? sDir : -sDir) * (sDir == oDir ? 2 : 3)
    sentiment

getSentimentDetails(sentiment) =>
    sentimentSymbol = sentiment == 4 ? '⬆' : sentiment == -4 ? '⬇' : sentiment == 3 ? '↗' : sentiment == -3 ? '↘' : sentiment == 2 ? '⤴' : sentiment == -2 ? '⤵' : sentiment == 1 ? '⤒' : sentiment == -1 ? '⤓' : '▣'
    sentimentColor = sentiment == 4 ? color.green : sentiment == -4 ? color.red : sentiment == 3 ? color.lime : sentiment == -3 ? color.orange : sentiment == 2 ? color.rgb(202, 224, 13, 0) : sentiment == -2 ? color.rgb(250, 128, 114, 0) : color.silver
    sentimentLabel = math.abs(sentiment) == 4 ? 'C' : math.abs(sentiment) == 3 ? 'H' : math.abs(sentiment) == 2 ? 'D' : 'I'
    [sentimentSymbol, sentimentLabel, sentimentColor]

getDoubleDivergenceDetails(doubleDivergence)=>
    doubleDivergence >0? '⬆'  : doubleDivergence<0? '⬇' : '▣'
    
addnewpivot(zigzagpivots, zigzagpivotbars, zigzagpivotdirs, zigzagpivotratios, zigzagoscillators,
                                     zigzagoscillatordirs, zigzagtrendbias, zigzagdivergence, zigzagdoubledivergence, 
                                     value, bar, dir, numberOfPivots,
                                     oscHigh, oscLow, directionBias, divergenceOption) =>
    newDir = dir
    oscDir = dir
    lPDir = 0
    lODir = 0
    ratio = 1.0
    oscillatorSource = dir > 0? oscHigh[bar_index - bar] : oscLow[bar_index - bar]
    if array.size(zigzagpivots) >= 2
        lastPoint = array.get(zigzagpivots, 0)
        llastPoint = array.get(zigzagpivots, 1)
        newDir := dir * value > dir * llastPoint ? dir * 2 : dir
        ratio := math.round(math.abs(value-lastPoint)/math.abs(llastPoint-lastPoint), 2)
        
        llastOsc = array.get(zigzagoscillators, 1)
        oscDir := dir * oscillatorSource > dir * llastOsc ? dir * 2 : dir
        if array.size(zigzagpivots) >=4
            lllastPoint = array.get(zigzagpivots, 3)
            lllastOsc = array.get(zigzagoscillators, 3)
            lODir := dir * llastOsc > dir * lllastOsc ? dir * 2 : dir
            lPDir := dir * llastPoint > dir * lllastPoint ? dir * 2 : dir
            
        
    sentiment = getSentiment(newDir, oscDir, directionBias[bar_index-bar])
    llastSentiment = array.size(zigzagdivergence) >=2 ? array.get(zigzagdivergence, 1): na
    
    useHiddenDoubleD = divergenceOption == 1 or divergenceOption == 3
    useRegularDoubleD = divergenceOption == 1 or divergenceOption == 2
    doubleDivergence = (sentiment == llastSentiment and ((math.abs(sentiment) == 3 and useHiddenDoubleD) or (math.abs(sentiment) == 2 and useRegularDoubleD))) ? sentiment/math.abs(sentiment) : 0
    
    add_to_array(zigzagpivots, value, numberOfPivots)
    add_to_array(zigzagpivotbars, bar, numberOfPivots)
    add_to_array(zigzagpivotdirs, newDir, numberOfPivots)
    add_to_array(zigzagpivotratios, ratio, numberOfPivots)
    add_to_array(zigzagoscillators, oscillatorSource, numberOfPivots)
    add_to_array(zigzagoscillatordirs, oscDir, numberOfPivots)
    add_to_array(zigzagtrendbias, directionBias[bar_index-bar], numberOfPivots)
    add_to_array(zigzagdivergence, sentiment, numberOfPivots)
    add_to_array(zigzagdoubledivergence, doubleDivergence, numberOfPivots)

zigzagcore(phigh, plow, phighbar, plowbar, numberOfPivots, oscHigh, oscLow, directionBias,
                                     zigzagpivots, zigzagpivotbars, zigzagpivotdirs, zigzagpivotratios, zigzagoscillators,
                                     zigzagoscillatordirs, zigzagtrendbias, zigzagdivergence, zigzagdoubledivergence, divergenceOption) =>
    pDir = 1
    newZG = false
    doubleZG = phigh and plow
    if array.size(zigzagpivots) >= 1
        pDir := array.get(zigzagpivotdirs, 0)
        pDir := pDir % 2 == 0 ? pDir / 2 : pDir
        pDir

    if (pDir == 1 and phigh or pDir == -1 and plow) and array.size(zigzagpivots) >= 1
        pivot = array.remove(zigzagpivots,0)
        pivotbar = array.remove(zigzagpivotbars,0)
        pivotdir = array.remove(zigzagpivotdirs,0)
        array.remove(zigzagpivotratios, 0)
        array.remove(zigzagoscillators, 0)
        array.remove(zigzagoscillatordirs, 0)
        array.remove(zigzagtrendbias, 0)
        array.remove(zigzagdivergence, 0)
        array.remove(zigzagdoubledivergence, 0)
        value = pDir == 1 ? phigh : plow
        bar = pDir == 1 ? phighbar : plowbar

        useNewValues = value * pivotdir > pivot * pivotdir
        value := useNewValues ? value : pivot
        bar := useNewValues ? bar : pivotbar
        newZG := newZG or useNewValues
        addnewpivot(zigzagpivots, zigzagpivotbars, zigzagpivotdirs, zigzagpivotratios, zigzagoscillators,
                                     zigzagoscillatordirs, zigzagtrendbias, zigzagdivergence, zigzagdoubledivergence, value, bar, pDir, numberOfPivots,
                                     oscHigh, oscLow, directionBias, divergenceOption)

    if pDir == 1 and plow or pDir == -1 and phigh
        value = pDir == 1 ? plow : phigh
        bar = pDir == 1 ? plowbar : phighbar
        dir = pDir == 1 ? -1 : 1
        newZG := true
        addnewpivot(zigzagpivots, zigzagpivotbars, zigzagpivotdirs, zigzagpivotratios, zigzagoscillators,
                                     zigzagoscillatordirs, zigzagtrendbias, zigzagdivergence, zigzagdoubledivergence, value, bar, dir, numberOfPivots,
                                     oscHigh, oscLow, directionBias, divergenceOption)

    [newZG, doubleZG]

draw_zg_line(idx1, idx2, zigzaglines, zigzaglabels, zigzagpivots, zigzagpivotbars, zigzagpivotdirs, zigzagpivotratios, zigzagdivergence,
                         zigzagcolor, zigzagwidth, zigzagstyle, showHighLow, showRatios, showDivergence) =>
    if array.size(zigzagpivots) > 2
        y1 = array.get(zigzagpivots, idx1)
        y2 = array.get(zigzagpivots, idx2)
        x1 = array.get(zigzagpivotbars, idx1)
        x2 = array.get(zigzagpivotbars, idx2)
        zline = line.new(x1=x1, y1=y1, x2=x2, y2=y2, color=zigzagcolor, width=zigzagwidth, style=zigzagstyle)
        currentDir = y1 > y2? 1 : -1
        label zlabel = na
        if(showHighLow or showRatios or showDivergence)
            dir = array.get(zigzagpivotdirs, idx1)
            ratio = array.get(zigzagpivotratios, idx1)
            sentiment = array.get(zigzagdivergence, idx1)
            [sentimentSymbol, sentimentLabel, sentimentColor] = getSentimentDetails(sentiment)
            [hhllText, labelColor] = switch dir
                1 => ["LH", color.orange]
                2 => ["HH", color.green]
                -1 => ["HL", color.lime]
                -2 => ["LL", color.red]
                => ["NA", color.silver]
            labelText = (showHighLow? hhllText : "") + 
                             (showHighLow and showRatios? " - " : "") +
                             (showRatios? str.tostring(ratio) : "") +
                             ((showHighLow or showRatios) and showDivergence? " : " : "") +
                             (showDivergence? sentimentSymbol : "")
            labelStyle = dir >= 0? label.style_label_down : label.style_label_up
            zlabel := label.new(x=x1, y=y1, yloc=yloc.price, color=showDivergence? sentimentColor : labelColor, style=labelStyle, text=labelText, 
                                     textcolor=color.black, size = size.small, tooltip=hhllText)
        if array.size(zigzaglines) > 0
            lastLine = array.get(zigzaglines, 0)
            if line.get_x2(lastLine) == x2 and line.get_x1(lastLine) <= x1
                line.delete(array.shift(zigzaglines))
                label.delete(array.shift(zigzaglabels))
        
        array.unshift(zigzaglines, zline)
        array.unshift(zigzaglabels, zlabel)
        if array.size(zigzaglines) > 500
            line.delete(array.pop(zigzaglines))
            label.delete(array.pop(zigzaglabels))


draw_zg_line2(idx1, idx2, zigzaglines, zigzaglabels, zigzagpivots, zigzagpivotbars, zigzagpivotdirs,
                         zigzagpivotratios, zigzagoscillators, zigzagdivergence, zigzagdoubledivergence,
                         zigzagcolor, zigzagwidth, zigzagstyle, showHighLow, showRatios, showDivergence, showDoubleDivergence, showIndicator) =>
    if array.size(zigzagpivots) > 2
        y1 = array.get(zigzagpivots, idx1)
        y2 = array.get(zigzagpivots, idx2)
        x1 = array.get(zigzagpivotbars, idx1)
        x2 = array.get(zigzagpivotbars, idx2)
        zline = line.new(x1=x1, y1=y1, x2=x2, y2=y2, color=zigzagcolor, width=zigzagwidth, style=zigzagstyle)
        currentDir = y1 > y2? 1 : -1
        label zlabel = na
        if(showHighLow or showRatios or showDivergence or showIndicator or showDoubleDivergence)
            dir = array.get(zigzagpivotdirs, idx1)
            ratio = array.get(zigzagpivotratios, idx1)
            sentiment = array.get(zigzagdivergence, idx1)
            doubleDivergence = array.get(zigzagdoubledivergence, idx1)
            [sentimentSymbol, sentimentLabel, sentimentColor] = getSentimentDetails(sentiment)
            ddLabel = getDoubleDivergenceDetails(doubleDivergence)
            oscillator = array.get(zigzagoscillators, idx1)
            [hhllText, labelColor] = switch dir
                1 => ["LH", color.orange]
                2 => ["HH", color.green]
                -1 => ["HL", color.lime]
                -2 => ["LL", color.red]
                => ["NA", color.silver]
            labelText = (showHighLow? hhllText : "") + 
                             (showHighLow and showRatios? " - " : "") +
                             (showRatios? str.tostring(ratio) : "") +
                             ((showRatios or showHighLow) and showIndicator? " - " : "") +
                             (showIndicator ? str.tostring(oscillator) : "") +
                             ((showHighLow or showRatios or showIndicator) and (showDivergence or showDoubleDivergence)? " : " : "") +
                             (showDivergence? sentimentSymbol : "") +
                             (showDivergence and showDoubleDivergence? "/" : "")+
                             (showDoubleDivergence? ddLabel : "")
                             
            labelStyle = dir >= 0? label.style_label_down : label.style_label_up
            zlabel := label.new(x=x1, y=y1, yloc=yloc.price, color=showDivergence? sentimentColor : labelColor, style=labelStyle, text=labelText, 
                                     textcolor=color.black, size = size.small, tooltip=hhllText)
        if array.size(zigzaglines) > 0
            lastLine = array.get(zigzaglines, 0)
            if line.get_x2(lastLine) == x2 and line.get_x1(lastLine) <= x1
                line.delete(array.shift(zigzaglines))
                label.delete(array.shift(zigzaglabels))
        
        array.unshift(zigzaglines, zline)
        array.unshift(zigzaglabels, zlabel)
        if array.size(zigzaglines) > 500
            line.delete(array.pop(zigzaglines))
            label.delete(array.pop(zigzaglabels))

// @function zigzag: Calculates zigzag pivots and generates an array
// @param   length                  : Zigzag Length
// @param   numberOfPivots          : Max number of pivots to return in the array. Default is 20
// @param   useAlternativeSource    : If set uses the source for genrating zigzag. Default is false
// @param   source                  : Alternative source used only if useAlternativeSource is set to true. Default is close
// @param   oscillatorSource        : Oscillator source for calculating divergence
// @param   directionBias           : Direction bias for calculating divergence
// @param   divergenceOption        : 1 - hidden/regular, 2 - regular, 3 - hidden
// @returns zigzagpivots        : Array containing zigzag pivots
//          zigzagpivotbars     : Array containing zigzag pivot bars
//          zigzagpivotdirs     : Array containing zigzag pivot directions (Lower High : 1, Higher High : 2, Lower Low : -2 and Higher Low : -1)
//          zigzagpivotratios   : Array containing zigzag retracement ratios for each pivot
//          zigzagoscillators   : Array of oscillator values at pivots. Will have valid values only if valid oscillatorSource is provided as per input.
//          zigzagoscillatordirs: Array of oscillator directions (HH, HL, LH, LL) at pivots. Will have valid values only if valid oscillatorSource is provided as per input.
//          zigzagtrendbias     : Array of trend bias at pivots. Will have valid value only if directionBias series is sent in input parameters
//          zigzagdivergence    :   Array of divergence sentiment at each pivot. Will have valid values only if oscillatorSource and directionBias inputs are provided
//          newPivot            : Returns true if new pivot created
//          doublePivot         : Returns true if two new pivots are created on same bar (Happens in case of candles with long wicks and shorter zigzag lengths)
zigzag(int length, simple int numberOfPivots = 20, simple bool useAlternativeSource = false, float source=close, 
         float oscillatorSource = close, float oscillatorHighSource = high, float oscillatorLowSource  = close, int directionBias = 1, int divergenceOption=1) =>
    var zigzagpivots = array.new_float(0)
    var zigzagpivotbars = array.new_int(0)
    var zigzagpivotdirs = array.new_int(0)
    var zigzagpivotratios = array.new_float(0)
    var zigzagoscillators = array.new_float(0)
    var zigzagoscillatordirs = array.new_int(0)
    var zigzagtrendbias = array.new_int(0)
    var zigzagdivergence = array.new_int(0)
    var zigzagdoubledivergence = array.new_int(0)
    oscHigh = not useAlternativeSource and oscillatorHighSource!= source? oscillatorHighSource : oscillatorSource
    oscLow = not useAlternativeSource and oscillatorLowSource != source? oscillatorLowSource : oscillatorSource
    highSource = useAlternativeSource ? source : high
    lowSource = useAlternativeSource ? source : low
    [phigh, plow, phighbar, plowbar] = pivots(length, highSource, lowSource)
    [newPivot, doublePivot] = zigzagcore(phigh, plow, phighbar, plowbar, numberOfPivots,
                                     oscHigh, oscLow, directionBias,
                                     zigzagpivots, zigzagpivotbars, zigzagpivotdirs, zigzagpivotratios, zigzagoscillators,
                                     zigzagoscillatordirs, zigzagtrendbias, zigzagdivergence, zigzagdoubledivergence, divergenceOption)
    [zigzagpivots, zigzagpivotbars, zigzagpivotdirs, zigzagpivotratios, zigzagoscillators,
                                     zigzagoscillatordirs, zigzagtrendbias, zigzagdivergence, zigzagdoubledivergence,
                                     newPivot, doublePivot]


// @function czigzag: Calculates zigzag pivots and generates an array based on custom high and low source
// @param   length                  : Zigzag Length
// @param   numberOfPivots          : Max number of pivots to return in the array. Default is 20
// @param   highSource              : High Source for prices to calculate zigzag.
// @param   lowSource               : Low source for prices to calculate zigzag.
// @param   oscillatorHighSource    : Oscillator high source for calculating divergence
// @param   oscillatorLowSource     : Oscillator high source for calculating divergence
// @param   directionBias           : Direction bias for calculating divergence
// @param   divergenceOption        : 1 - hidden/regular, 2 - regular, 3 - hidden
// @returns zigzagpivots        : Array containing zigzag pivots
//          zigzagpivotbars     : Array containing zigzag pivot bars
//          zigzagpivotdirs     : Array containing zigzag pivot directions (Lower High : 1, Higher High : 2, Lower Low : -2 and Higher Low : -1)
//          zigzagpivotratios   : Array containing zigzag retracement ratios for each pivot
//          zigzagoscillators   : Array of oscillator values at pivots. Will have valid values only if valid oscillatorSource is provided as per input.
//          zigzagoscillatordirs: Array of oscillator directions (HH, HL, LH, LL) at pivots. Will have valid values only if valid oscillatorSource is provided as per input.
//          zigzagtrendbias     : Array of trend bias at pivots. Will have valid value only if directionBias series is sent in input parameters
//          zigzagdivergence    :   Array of divergence sentiment at each pivot. Will have valid values only if oscillatorSource and directionBias inputs are provided
//          zigzagdoubledivergence : Array of double divergence sentiment at each pivot
//          newPivot            : Returns true if new pivot created
//          doublePivot         : Returns true if two new pivots are created on same bar (Happens in case of candles with long wicks and shorter zigzag lengths)
czigzag(int length, simple int numberOfPivots = 20, float highSource = high, float lowSource = low, 
                 float oscillatorHighSource = high, float oscillatorLowSource  = low, int directionBias = 1, int divergenceOption=1) =>
    var zigzagpivots = array.new_float(0)
    var zigzagpivotbars = array.new_int(0)
    var zigzagpivotdirs = array.new_int(0)
    var zigzagpivotratios = array.new_float(0)
    var zigzagoscillators = array.new_float(0)
    var zigzagoscillatordirs = array.new_int(0)
    var zigzagtrendbias = array.new_int(0)
    var zigzagdivergence = array.new_int(0)
    var zigzagdoubledivergence = array.new_int(0)
    [phigh, plow, phighbar, plowbar] = pivots(length, highSource, lowSource)
    [newPivot, doublePivot] = zigzagcore(phigh, plow, phighbar, plowbar, numberOfPivots,
                                     oscillatorHighSource, oscillatorLowSource, directionBias,
                                     zigzagpivots, zigzagpivotbars, zigzagpivotdirs, zigzagpivotratios, zigzagoscillators,
                                     zigzagoscillatordirs, zigzagtrendbias, zigzagdivergence, zigzagdoubledivergence, divergenceOption)
    [zigzagpivots, zigzagpivotbars, zigzagpivotdirs, zigzagpivotratios, zigzagoscillators,
                                     zigzagoscillatordirs, zigzagtrendbias, zigzagdivergence, zigzagdoubledivergence,
                                     newPivot, doublePivot]


// @function drawczigzag: Calculates and draws zigzag pivots and generates an array based on custom high and low source
// @param   length                  : Zigzag Length
// @param   numberOfPivots          : Max number of pivots to return in the array. Default is 20
// @param   highSource              : High Source for prices to calculate zigzag.
// @param   lowSource               : Low source for prices to calculate zigzag.
// @param   oscillatorHighSource    : Oscillator high source for calculating divergence
// @param   oscillatorLowSource     : Oscillator high source for calculating divergence
// @param   directionBias           : Direction bias for calculating divergence
// @param   showHighLow             : show highlow label
// @param   showRatios              : show retracement ratios
// @param   showDivergence          : Show divergence on label (Only works if divergence data is available - that is if we pass valid oscillatorSource and directionBias input)
// @param   showDoubleDivergence    : Show double divergence label
// @param   linecolor               : zigzag line color
// @param   linewidth               : zigzag line width
// @param   linestyle               : zigzag line style
// @returns zigzagpivots        : Array containing zigzag pivots
//          zigzagpivotbars     : Array containing zigzag pivot bars
//          zigzagpivotdirs     : Array containing zigzag pivot directions (Lower High : 1, Higher High : 2, Lower Low : -2 and Higher Low : -1)
//          zigzagpivotratios   : Array containing zigzag retracement ratios for each pivot
//          zigzagoscillators   : Array of oscillator values at pivots. Will have valid values only if valid oscillatorSource is provided as per input.
//          zigzagoscillatordirs: Array of oscillator directions (HH, HL, LH, LL) at pivots. Will have valid values only if valid oscillatorSource is provided as per input.
//          zigzagtrendbias     : Array of trend bias at pivots. Will have valid value only if directionBias series is sent in input parameters
//          zigzagdivergence    :   Array of divergence sentiment at each pivot. Will have valid values only if oscillatorSource and directionBias inputs are provided
//          zigzagdoubledivergence : Array of double divergence sentiment at each pivot
//          zigzaglines         : Returns array of zigzag lines
//          zigzaglabels        : Returns array of zigzag labels
drawczigzag(int length, simple int numberOfPivots = 20, float highSource = high, float lowSource = low, 
                 float oscillatorHighSource = high, float oscillatorLowSource  = low, int directionBias = 1, 
                 simple bool showHighLow=false, simple bool showRatios = false, simple bool showDivergence = false, 
                 simple bool showDoubleDivergence = false, simple bool showIndicator = false, 
                 color linecolor = color.blue, int linewidth = 1, string linestyle = line.style_solid)=>
    [zigzagpivots, zigzagpivotbars, zigzagpivotdirs, zigzagpivotratios, zigzagoscillators,
                                 zigzagoscillatordirs, zigzagtrendbias, zigzagdivergence, zigzagdoubledivergence,
                                 newPivot, doublePivot] = czigzag(length, numberOfPivots, highSource, lowSource, oscillatorHighSource, oscillatorLowSource, directionBias)
    var zigzaglines = array.new_line(0)
    var zigzaglabels = array.new_label(0)
    if(newPivot)
        if doublePivot
            draw_zg_line2(1, 2, zigzaglines, zigzaglabels, zigzagpivots, zigzagpivotbars, zigzagpivotdirs, 
                             zigzagpivotratios, zigzagoscillators, zigzagdivergence, zigzagdoubledivergence,
                             linecolor, linewidth, linestyle, showHighLow, showRatios, showDivergence, showDoubleDivergence, showIndicator)

        if array.size(zigzagpivots) >= 2
            draw_zg_line2(0, 1, zigzaglines, zigzaglabels, zigzagpivots, zigzagpivotbars, zigzagpivotdirs,
                             zigzagpivotratios, zigzagoscillators, zigzagdivergence, zigzagdoubledivergence,
                             linecolor, linewidth, linestyle, showHighLow, showRatios, showDivergence, showDoubleDivergence, showIndicator)
    [zigzagpivots, zigzagpivotbars, zigzagpivotdirs, zigzagpivotratios, zigzagoscillators,
                                     zigzagoscillatordirs, zigzagtrendbias, zigzagdivergence, zigzagdoubledivergence,
                                     zigzaglines, zigzaglabels]


// @function drawczigzag2: Same as drawczigzag. But, returns newPivot and doublePivot bools as well.
// @param   length                  : Zigzag Length
// @param   numberOfPivots          : Max number of pivots to return in the array. Default is 20
// @param   highSource              : High Source for prices to calculate zigzag.
// @param   lowSource               : Low source for prices to calculate zigzag.
// @param   oscillatorHighSource    : Oscillator high source for calculating divergence
// @param   oscillatorLowSource     : Oscillator high source for calculating divergence
// @param   directionBias           : Direction bias for calculating divergence
// @param   showHighLow             : show highlow label
// @param   showRatios              : show retracement ratios
// @param   showDivergence          : Show divergence on label (Only works if divergence data is available - that is if we pass valid oscillatorSource and directionBias input)
// @param   showDoubleDivergence    : Show double divergence label
// @param   linecolor               : zigzag line color
// @param   linewidth               : zigzag line width
// @param   linestyle               : zigzag line style
// @returns zigzagpivots        : Array containing zigzag pivots
//          zigzagpivotbars     : Array containing zigzag pivot bars
//          zigzagpivotdirs     : Array containing zigzag pivot directions (Lower High : 1, Higher High : 2, Lower Low : -2 and Higher Low : -1)
//          zigzagpivotratios   : Array containing zigzag retracement ratios for each pivot
//          zigzagoscillators   : Array of oscillator values at pivots. Will have valid values only if valid oscillatorSource is provided as per input.
//          zigzagoscillatordirs: Array of oscillator directions (HH, HL, LH, LL) at pivots. Will have valid values only if valid oscillatorSource is provided as per input.
//          zigzagtrendbias     : Array of trend bias at pivots. Will have valid value only if directionBias series is sent in input parameters
//          zigzagdivergence    :   Array of divergence sentiment at each pivot. Will have valid values only if oscillatorSource and directionBias inputs are provided
//          zigzagdoubledivergence : Array of double divergence sentiment at each pivot
//          zigzaglines         : Returns array of zigzag lines
//          zigzaglabels        : Returns array of zigzag labels
drawczigzag2(int length, simple int numberOfPivots = 20, float highSource = high, float lowSource = low, 
                 float oscillatorHighSource = high, float oscillatorLowSource  = low, int directionBias = 1, 
                 simple bool showHighLow=false, simple bool showRatios = false, simple bool showDivergence = false, 
                 simple bool showDoubleDivergence = false, simple bool showIndicator = false, 
                 color linecolor = color.blue, int linewidth = 1, string linestyle = line.style_solid)=>
    [zigzagpivots, zigzagpivotbars, zigzagpivotdirs, zigzagpivotratios, zigzagoscillators,
                                 zigzagoscillatordirs, zigzagtrendbias, zigzagdivergence, zigzagdoubledivergence,
                                 newPivot, doublePivot] = czigzag(length, numberOfPivots, highSource, lowSource, oscillatorHighSource, oscillatorLowSource, directionBias)
    var zigzaglines = array.new_line(0)
    var zigzaglabels = array.new_label(0)
    if(newPivot)
        if doublePivot
            draw_zg_line2(1, 2, zigzaglines, zigzaglabels, zigzagpivots, zigzagpivotbars, zigzagpivotdirs, 
                             zigzagpivotratios, zigzagoscillators, zigzagdivergence, zigzagdoubledivergence,
                             linecolor, linewidth, linestyle, showHighLow, showRatios, showDivergence, showDoubleDivergence, showIndicator)

        if array.size(zigzagpivots) >= 2
            draw_zg_line2(0, 1, zigzaglines, zigzaglabels, zigzagpivots, zigzagpivotbars, zigzagpivotdirs,
                             zigzagpivotratios, zigzagoscillators, zigzagdivergence, zigzagdoubledivergence,
                             linecolor, linewidth, linestyle, showHighLow, showRatios, showDivergence, showDoubleDivergence, showIndicator)
    [zigzagpivots, zigzagpivotbars, zigzagpivotdirs, zigzagpivotratios, zigzagoscillators,
                                     zigzagoscillatordirs, zigzagtrendbias, zigzagdivergence, zigzagdoubledivergence,
                                     newPivot, doublePivot, zigzaglines, zigzaglabels]
                                     
// @function drawzigzag: Calculates and draws zigzag pivots
// @param   length              : Zigzag Length
// @param   numberOfPivots      : Max number of pivots to return in the array. Default is 20
// @param   useAlternativeSource: If set uses the source for genrating zigzag. Default is false
// @param   source              : Alternative source used only if useAlternativeSource is set to true. Default is close
// @param   linecolor           : zigzag line color
// @param   linewidth           : zigzag line width
// @param   linestyle           : zigzag line style
// @param   oscillatorSource    : Oscillator source for calculating divergence
// @param   directionBias       : Direction bias for calculating divergence
// @param   showHighLow         : show highlow label
// @param   showRatios          : show retracement ratios
// @param   showDivergence      : Show divergence on label (Only works if divergence data is available - that is if we pass valid oscillatorSource and directionBias input)
// @returns zigzagpivots        : Array containing zigzag pivots
//          zigzagpivotbars     : Array containing zigzag pivot bars
//          zigzagpivotdirs     : Array containing zigzag pivot directions (Lower High : 1, Higher High : 2, Lower Low : -2 and Higher Low : -1)
//          zigzagpivotratios   : Array containing zigzag retracement ratios for each pivot
//          zigzagoscillators   : Array of oscillator values at pivots. Will have valid values only if valid oscillatorSource is provided as per input.
//          zigzagoscillatordirs: Array of oscillator directions (HH, HL, LH, LL) at pivots. Will have valid values only if valid oscillatorSource is provided as per input.
//          zigzagtrendbias     : Array of trend bias at pivots. Will have valid value only if directionBias series is sent in input parameters
//          zigzagdivergence    :   Array of divergence sentiment at each pivot. Will have valid values only if oscillatorSource and directionBias inputs are provided
//          zigzaglines         : Returns array of zigzag lines
//          zigzaglabels        : Returns array of zigzag labels
drawzigzag(int length, simple int numberOfPivots = 20, simple bool useAlternativeSource = false, float source=close,
                     color linecolor = color.blue, int linewidth = 1, string linestyle = line.style_solid,
                     float oscillatorSource = close,  float oscillatorHighSource = high, float oscillatorLowSource = close, int directionBias = 1,
                     simple bool showHighLow=false, simple bool showRatios = false, simple bool showDivergence = false)=>
    [zigzagpivots, zigzagpivotbars, zigzagpivotdirs, zigzagpivotratios, zigzagoscillators,
                                     zigzagoscillatordirs, zigzagtrendbias, zigzagdivergence, zigzagdoubledivergence,
                                     newPivot, doublePivot] = zigzag(length, numberOfPivots, useAlternativeSource, source, 
                                                                     oscillatorSource, oscillatorHighSource, oscillatorLowSource, directionBias)
    var zigzaglines = array.new_line(0)
    var zigzaglabels = array.new_label(0)
    if(newPivot)
        if doublePivot
            draw_zg_line(1, 2, zigzaglines, zigzaglabels, zigzagpivots, zigzagpivotbars, zigzagpivotdirs, zigzagpivotratios, zigzagdivergence,
                             linecolor, linewidth, linestyle, showHighLow, showRatios, showDivergence)

        if array.size(zigzagpivots) >= 2
            draw_zg_line(0, 1, zigzaglines, zigzaglabels, zigzagpivots, zigzagpivotbars, zigzagpivotdirs, zigzagpivotratios, zigzagdivergence,
                             linecolor, linewidth, linestyle, showHighLow, showRatios, showDivergence)
    [zigzagpivots, zigzagpivotbars, zigzagpivotdirs, zigzagpivotratios, zigzagoscillators,
                                     zigzagoscillatordirs, zigzagtrendbias, zigzagdivergence, 
                                     zigzaglines, zigzaglabels]


import HeWhoMustNotBeNamed/arrayutils/17 as pa


l = input.int(5, 'Length', step=1, group='Zigzag')

displayTooltip = 'REGULAR : green bars for upswing and red bars for downswing volume. Moiving average can be applied to this type of display\n\n'+
                     'PLUS/MINUS - STACKED : both upswing and downswing will have positive and negative volumne bars stacked on each other. If the first bar is green or red depends on stacking style\n\n'+
                     'PLUS/MINUS - OVERLAPPING : both positive and negative volume bars are shown. But, both starts from zero and overlaps each other.\n\n'+
                     'PLUS/MINUS - OPPOSITE SIDES : positive volume is shown from 0 to upside whereas negative volume bars are shown from 0 to downwards\n'
displayType = input.string('regular', 'Bar Style', options=['regular', 'plus/minus - stacked', 'plus/minus - overlapping', 'plus/minus - opposite sides'], group='Display', tooltip=displayTooltip)

stackingTooltop = 'DIRECTION-BASED : Up volume(green) bar is placed first on upswing and down volume(red) bar is placed. first on downswing\n\n'+
                     'GREEN-FIRST : Up volume(green) bar is always placed first\n\n'+
                     'RED-FIRST : Down volume(red) bar is always placed first\n\n'+
                     'HIGHEST-FIRST : Bar with highest portion of volume is placed first\n\n'+
                     'LOWEST-FIRST : Bar with lowest portion of volume is placed first'
stackedStyle = input.string('direction-based', 'Stack Style', options=['direction-based', 'green-first', 'red-first', 'highest-first', 'lowest-first'], group='Display', tooltip=stackingTooltop)

//Ma is only applicable for few display styles
applyMa = input.bool(true, 'Show MA', group='Moving Average', inline='ma')
maType = input.string('sma', '', options=["sma", "ema", "hma", "rma", "wma"], group='Moving Average', inline='ma')
maLength = input.int(20, '', step=1, group='Moving Average', inline='ma', tooltip='Moving average is applied only for display types - REGULAR, PLUS/MINUS - OPPOSITE SIDES')

//Volume plot style - boolean flags
plotDifferentialVolume = displayType != 'regular'
plotOnDifferentSides = displayType == 'plus/minus - opposite sides'
overlap = displayType == 'plus/minus - overlapping'
stacked = displayType == 'plus/minus - stacked'
displayMaRegular = applyMa and not plotDifferentialVolume
displayMaBiDirectional = applyMa and plotDifferentialVolume and plotOnDifferentSides

//Stacking style if plot style is stacked bars
directionalStacking = stackedStyle == 'direction-based'
greenFirst = stackedStyle == 'green-first'
redFirst = stackedStyle == 'red-first'
highestFirst = stackedStyle == 'highest-first'
lowestFirst = stackedStyle == 'lowest-first'

[zigzagpivots, zigzagpivotbars, zigzagpivotdirs, _, _, _, _, _, _, newPivot, doublePivot] = czigzag(l,20,sig[w],sig[w],sig[w],sig[w])
var volumeArray = array.new_float()
var uVolumeArray = array.new_float()
var lVolumeArray = array.new_float()
var int lastBar = na
if(array.size(zigzagpivots)>1)
    currentBar = array.get(zigzagpivotbars, 0)
    lastBar := array.get(zigzagpivotbars, 1)

    currentDir = array.get(zigzagpivotdirs, 0)
    
    zvolumeplus = 0.0
    zvolumeminus = 0.0
    for i=lastBar==currentBar? na : lastBar+1 to currentBar-1
        zvolumeminus += (o_p_e_n[bar_index-i] > c_l_o_s_e[bar_index-i] ? v_o_l_u_m_e[bar_index-i] : 0)
        zvolumeplus += (o_p_e_n[bar_index-i] > c_l_o_s_e[bar_index-i] ? 0 : v_o_l_u_m_e[bar_index-i])

    zvolumeminus += (o_p_e_n[bar_index-currentBar] > c_l_o_s_e[bar_index-currentBar] ? v_o_l_u_m_e[bar_index-currentBar] : 0)
    zvolumeplus += (o_p_e_n[bar_index-currentBar] > c_l_o_s_e[bar_index-currentBar] ? 0 : v_o_l_u_m_e[bar_index-currentBar])
    
    zvolumeminus += (o_p_e_n[bar_index-lastBar] > c_l_o_s_e[bar_index-lastBar] ? v_o_l_u_m_e[bar_index-lastBar] : 0)
    zvolumeplus += (o_p_e_n[bar_index-lastBar] > c_l_o_s_e[bar_index-lastBar] ? 0 : v_o_l_u_m_e[bar_index-lastBar])
    zvolume = zvolumeplus + zvolumeminus

    zvolumeminus := plotOnDifferentSides? -zvolumeminus : zvolumeminus
    if(plotDifferentialVolume)
        var box ubar = na
        var box lbar = na
        if(lastBar == lastBar[1] and currentBar != lastBar)
            box.delete(ubar)
            box.delete(lbar)
            array.shift(uVolumeArray)
            array.shift(lVolumeArray)
        else
            box.set_right(ubar, lastBar)
            box.set_right(lbar, lastBar)
            box.set_bgcolor(ubar, color.new(color.green, 70))
            box.set_bgcolor(lbar, color.new(color.red, 70))
        
        uStart = plotOnDifferentSides or overlap? 0 :
                     directionalStacking? (currentDir > 0? 0 : zvolumeminus) :
                     greenFirst ? 0 : redFirst ? zvolumeminus : 
                     highestFirst ? (zvolumeplus > zvolumeminus ? 0 : zvolumeminus) : 
                     lowestFirst ? (zvolumeplus > zvolumeminus ? zvolumeminus : 0) : na
        
        uEnd = uStart + zvolumeplus
        
        lStart = plotOnDifferentSides or overlap? 0 :
                     directionalStacking? (currentDir > 0? zvolumeplus : 0) :
                     greenFirst ? zvolumeplus : redFirst ? 0 : 
                     highestFirst ? (zvolumeplus > zvolumeminus ? zvolumeplus : 0) : 
                     lowestFirst ? (zvolumeplus > zvolumeminus ? 0 : zvolumeplus) : na
        lEnd = lStart + zvolumeminus
        
        ubar := box.new(left=lastBar, top=uEnd, right=currentBar, bottom=uStart, bgcolor = color.new(color.green, 20))
        pa.unshift(uVolumeArray, zvolumeplus, maLength)

        lbar := box.new(left=lastBar, top=lEnd, right=currentBar, bottom=lStart, bgcolor = color.new(color.red, 20))
        pa.unshift(lVolumeArray, zvolumeminus, maLength)
    else
        var box vbar = na
        barColor = currentDir>0? color.green: color.red
        if(lastBar == lastBar[1] and currentBar != lastBar)
            box.delete(vbar)
            array.shift(volumeArray)
        else
            box.set_right(vbar, lastBar)
            box.set_bgcolor(vbar, color.new(barColor[1], 70))
        vbar := box.new(left=lastBar, top=zvolume, right=currentBar, bottom=0, bgcolor = color.new(barColor, 20))
        pa.unshift(volumeArray, zvolume, maLength)
vma = pa.ma(volumeArray, maType, maLength)
vmaPlus = pa.ma(uVolumeArray, maType, maLength)
vmaMinus = pa.ma(lVolumeArray, maType, maLength)

plot(displayMaRegular?vma:na, 'Volume moving average')
plot(displayMaBiDirectional?vmaPlus:na, 'Plus Volume moving average', color=color.green)
plot(displayMaBiDirectional?vmaMinus:na, 'Minus Volume moving average', color=color.red)
