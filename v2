// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © ZoeUdokpan

//@version=5
indicator("EHLERS.VOLUME.BARS")


c_l_o_s_e = ta.valuewhen(open > ta.ema(high,2) , close, 0)

o_p_e_n = open
h_i_g_h = math.max(c_l_o_s_e,o_p_e_n)
l_o_w = math.min(c_l_o_s_e,o_p_e_n)
v_o_l_u_m_e = volume


//-----------------------ZIG ZAG CODE
add_to_array(arr, val, maxItems) =>
    array.insert(arr, 0, val)
    if array.size(arr) > maxItems
        array.pop(arr)

pivots(length, highSource=high, lowSource = low) =>
    float phigh = ta.highestbars(highSource, length) == 0 ? highSource : na
    float plow = ta.lowestbars(lowSource, length) == 0 ? lowSource : na
    [phigh, plow, bar_index, bar_index]

getSentiment(pDir, oDir, sDir) =>
    sentiment = pDir == oDir ? sDir == pDir or sDir * 2 == -pDir ? -sDir : sDir * 4 : sDir == pDir or sDir == -oDir ? 0 : (math.abs(oDir) > math.abs(pDir) ? sDir : -sDir) * (sDir == oDir ? 2 : 3)
    sentiment

getSentimentDetails(sentiment) =>
    sentimentSymbol = sentiment == 4 ? '⬆' : sentiment == -4 ? '⬇' : sentiment == 3 ? '↗' : sentiment == -3 ? '↘' : sentiment == 2 ? '⤴' : sentiment == -2 ? '⤵' : sentiment == 1 ? '⤒' : sentiment == -1 ? '⤓' : '▣'
    sentimentColor = sentiment == 4 ? color.green : sentiment == -4 ? color.red : sentiment == 3 ? color.lime : sentiment == -3 ? color.orange : sentiment == 2 ? color.rgb(202, 224, 13, 0) : sentiment == -2 ? color.rgb(250, 128, 114, 0) : color.silver
    sentimentLabel = math.abs(sentiment) == 4 ? 'C' : math.abs(sentiment) == 3 ? 'H' : math.abs(sentiment) == 2 ? 'D' : 'I'
    [sentimentSymbol, sentimentLabel, sentimentColor]

getDoubleDivergenceDetails(doubleDivergence)=>
    doubleDivergence >0? '⬆'  : doubleDivergence<0? '⬇' : '▣'
    
addnewpivot(zigzagpivots, zigzagpivotbars, zigzagpivotdirs, zigzagpivotratios, zigzagoscillators,
                                     zigzagoscillatordirs, zigzagtrendbias, zigzagdivergence, zigzagdoubledivergence, 
                                     value, bar, dir, numberOfPivots,
                                     oscHigh, oscLow, directionBias, divergenceOption) =>
    newDir = dir
    oscDir = dir
    lPDir = 0
    lODir = 0
    ratio = 1.0
    oscillatorSource = dir > 0? oscHigh[bar_index - bar] : oscLow[bar_index - bar]
    if array.size(zigzagpivots) >= 2
        lastPoint = array.get(zigzagpivots, 0)
        llastPoint = array.get(zigzagpivots, 1)
        newDir := dir * value > dir * llastPoint ? dir * 2 : dir
        ratio := math.round(math.abs(value-lastPoint)/math.abs(llastPoint-lastPoint), 2)
        
        llastOsc = array.get(zigzagoscillators, 1)
        oscDir := dir * oscillatorSource > dir * llastOsc ? dir * 2 : dir
        if array.size(zigzagpivots) >=4
            lllastPoint = array.get(zigzagpivots, 3)
            lllastOsc = array.get(zigzagoscillators, 3)
            lODir := dir * llastOsc > dir * lllastOsc ? dir * 2 : dir
            lPDir := dir * llastPoint > dir * lllastPoint ? dir * 2 : dir
            
        
    sentiment = getSentiment(newDir, oscDir, directionBias[bar_index-bar])
    llastSentiment = array.size(zigzagdivergence) >=2 ? array.get(zigzagdivergence, 1): na
    
    useHiddenDoubleD = divergenceOption == 1 or divergenceOption == 3
    useRegularDoubleD = divergenceOption == 1 or divergenceOption == 2
    doubleDivergence = (sentiment == llastSentiment and ((math.abs(sentiment) == 3 and useHiddenDoubleD) or (math.abs(sentiment) == 2 and useRegularDoubleD))) ? sentiment/math.abs(sentiment) : 0
    
    add_to_array(zigzagpivots, value, numberOfPivots)
    add_to_array(zigzagpivotbars, bar, numberOfPivots)
    add_to_array(zigzagpivotdirs, newDir, numberOfPivots)
    add_to_array(zigzagpivotratios, ratio, numberOfPivots)
    add_to_array(zigzagoscillators, oscillatorSource, numberOfPivots)
    add_to_array(zigzagoscillatordirs, oscDir, numberOfPivots)
    add_to_array(zigzagtrendbias, directionBias[bar_index-bar], numberOfPivots)
    add_to_array(zigzagdivergence, sentiment, numberOfPivots)
    add_to_array(zigzagdoubledivergence, doubleDivergence, numberOfPivots)

zigzagcore(phigh, plow, phighbar, plowbar, numberOfPivots, oscHigh, oscLow, directionBias,
                                     zigzagpivots, zigzagpivotbars, zigzagpivotdirs, zigzagpivotratios, zigzagoscillators,
                                     zigzagoscillatordirs, zigzagtrendbias, zigzagdivergence, zigzagdoubledivergence, divergenceOption) =>
    pDir = 1
    newZG = false
    doubleZG = phigh and plow
    if array.size(zigzagpivots) >= 1
        pDir := array.get(zigzagpivotdirs, 0)
        pDir := pDir % 2 == 0 ? pDir / 2 : pDir
        pDir

    if (pDir == 1 and phigh or pDir == -1 and plow) and array.size(zigzagpivots) >= 1
        pivot = array.remove(zigzagpivots,0)
        pivotbar = array.remove(zigzagpivotbars,0)
        pivotdir = array.remove(zigzagpivotdirs,0)
        array.remove(zigzagpivotratios, 0)
        array.remove(zigzagoscillators, 0)
        array.remove(zigzagoscillatordirs, 0)
        array.remove(zigzagtrendbias, 0)
        array.remove(zigzagdivergence, 0)
        array.remove(zigzagdoubledivergence, 0)
        value = pDir == 1 ? phigh : plow
        bar = pDir == 1 ? phighbar : plowbar

        useNewValues = value * pivotdir > pivot * pivotdir
        value := useNewValues ? value : pivot
        bar := useNewValues ? bar : pivotbar
        newZG := newZG or useNewValues
        addnewpivot(zigzagpivots, zigzagpivotbars, zigzagpivotdirs, zigzagpivotratios, zigzagoscillators,
                                     zigzagoscillatordirs, zigzagtrendbias, zigzagdivergence, zigzagdoubledivergence, value, bar, pDir, numberOfPivots,
                                     oscHigh, oscLow, directionBias, divergenceOption)

    if pDir == 1 and plow or pDir == -1 and phigh
        value = pDir == 1 ? plow : phigh
        bar = pDir == 1 ? plowbar : phighbar
        dir = pDir == 1 ? -1 : 1
        newZG := true
        addnewpivot(zigzagpivots, zigzagpivotbars, zigzagpivotdirs, zigzagpivotratios, zigzagoscillators,
                                     zigzagoscillatordirs, zigzagtrendbias, zigzagdivergence, zigzagdoubledivergence, value, bar, dir, numberOfPivots,
                                     oscHigh, oscLow, directionBias, divergenceOption)

    [newZG, doubleZG]

draw_zg_line(idx1, idx2, zigzaglines, zigzaglabels, zigzagpivots, zigzagpivotbars, zigzagpivotdirs, zigzagpivotratios, zigzagdivergence,
                         zigzagcolor, zigzagwidth, zigzagstyle, showHighLow, showRatios, showDivergence) =>
    if array.size(zigzagpivots) > 2
        y1 = array.get(zigzagpivots, idx1)
        y2 = array.get(zigzagpivots, idx2)
        x1 = array.get(zigzagpivotbars, idx1)
        x2 = array.get(zigzagpivotbars, idx2)
        zline = line.new(x1=x1, y1=y1, x2=x2, y2=y2, color=zigzagcolor, width=zigzagwidth, style=zigzagstyle)
        currentDir = y1 > y2? 1 : -1
        label zlabel = na
        if(showHighLow or showRatios or showDivergence)
            dir = array.get(zigzagpivotdirs, idx1)
            ratio = array.get(zigzagpivotratios, idx1)
            sentiment = array.get(zigzagdivergence, idx1)
            [sentimentSymbol, sentimentLabel, sentimentColor] = getSentimentDetails(sentiment)
            [hhllText, labelColor] = switch dir
                1 => ["LH", color.orange]
                2 => ["HH", color.green]
                -1 => ["HL", color.lime]
                -2 => ["LL", color.red]
                => ["NA", color.silver]
            labelText = (showHighLow? hhllText : "") + 
                             (showHighLow and showRatios? " - " : "") +
                             (showRatios? str.tostring(ratio) : "") +
                             ((showHighLow or showRatios) and showDivergence? " : " : "") +
                             (showDivergence? sentimentSymbol : "")
            labelStyle = dir >= 0? label.style_label_down : label.style_label_up
            zlabel := label.new(x=x1, y=y1, yloc=yloc.price, color=showDivergence? sentimentColor : labelColor, style=labelStyle, text=labelText, 
                                     textcolor=color.black, size = size.small, tooltip=hhllText)
        if array.size(zigzaglines) > 0
            lastLine = array.get(zigzaglines, 0)
            if line.get_x2(lastLine) == x2 and line.get_x1(lastLine) <= x1
                line.delete(array.shift(zigzaglines))
                label.delete(array.shift(zigzaglabels))
        
        array.unshift(zigzaglines, zline)
        array.unshift(zigzaglabels, zlabel)
        if array.size(zigzaglines) > 500
            line.delete(array.pop(zigzaglines))
            label.delete(array.pop(zigzaglabels))


draw_zg_line2(idx1, idx2, zigzaglines, zigzaglabels, zigzagpivots, zigzagpivotbars, zigzagpivotdirs,
                         zigzagpivotratios, zigzagoscillators, zigzagdivergence, zigzagdoubledivergence,
                         zigzagcolor, zigzagwidth, zigzagstyle, showHighLow, showRatios, showDivergence, showDoubleDivergence, showIndicator) =>
    if array.size(zigzagpivots) > 2
        y1 = array.get(zigzagpivots, idx1)
        y2 = array.get(zigzagpivots, idx2)
        x1 = array.get(zigzagpivotbars, idx1)
        x2 = array.get(zigzagpivotbars, idx2)
        zline = line.new(x1=x1, y1=y1, x2=x2, y2=y2, color=zigzagcolor, width=zigzagwidth, style=zigzagstyle)
        currentDir = y1 > y2? 1 : -1
        label zlabel = na
        if(showHighLow or showRatios or showDivergence or showIndicator or showDoubleDivergence)
            dir = array.get(zigzagpivotdirs, idx1)
            ratio = array.get(zigzagpivotratios, idx1)
            sentiment = array.get(zigzagdivergence, idx1)
            doubleDivergence = array.get(zigzagdoubledivergence, idx1)
            [sentimentSymbol, sentimentLabel, sentimentColor] = getSentimentDetails(sentiment)
            ddLabel = getDoubleDivergenceDetails(doubleDivergence)
            oscillator = array.get(zigzagoscillators, idx1)
            [hhllText, labelColor] = switch dir
                1 => ["LH", color.orange]
                2 => ["HH", color.green]
                -1 => ["HL", color.lime]
                -2 => ["LL", color.red]
                => ["NA", color.silver]
            labelText = (showHighLow? hhllText : "") + 
                             (showHighLow and showRatios? " - " : "") +
                             (showRatios? str.tostring(ratio) : "") +
                             ((showRatios or showHighLow) and showIndicator? " - " : "") +
                             (showIndicator ? str.tostring(oscillator) : "") +
                             ((showHighLow or showRatios or showIndicator) and (showDivergence or showDoubleDivergence)? " : " : "") +
                             (showDivergence? sentimentSymbol : "") +
                             (showDivergence and showDoubleDivergence? "/" : "")+
                             (showDoubleDivergence? ddLabel : "")
                             
            labelStyle = dir >= 0? label.style_label_down : label.style_label_up
            zlabel := label.new(x=x1, y=y1, yloc=yloc.price, color=showDivergence? sentimentColor : labelColor, style=labelStyle, text=labelText, 
                                     textcolor=color.black, size = size.small, tooltip=hhllText)
        if array.size(zigzaglines) > 0
            lastLine = array.get(zigzaglines, 0)
            if line.get_x2(lastLine) == x2 and line.get_x1(lastLine) <= x1
                line.delete(array.shift(zigzaglines))
                label.delete(array.shift(zigzaglabels))
        
        array.unshift(zigzaglines, zline)
        array.unshift(zigzaglabels, zlabel)
        if array.size(zigzaglines) > 500
            line.delete(array.pop(zigzaglines))
            label.delete(array.pop(zigzaglabels))

// @function zigzag: Calculates zigzag pivots and generates an array
// @param   length                  : Zigzag Length
// @param   numberOfPivots          : Max number of pivots to return in the array. Default is 20
// @param   useAlternativeSource    : If set uses the source for genrating zigzag. Default is false
// @param   source                  : Alternative source used only if useAlternativeSource is set to true. Default is close
// @param   oscillatorSource        : Oscillator source for calculating divergence
// @param   directionBias           : Direction bias for calculating divergence
// @param   divergenceOption        : 1 - hidden/regular, 2 - regular, 3 - hidden
// @returns zigzagpivots        : Array containing zigzag pivots
//          zigzagpivotbars     : Array containing zigzag pivot bars
//          zigzagpivotdirs     : Array containing zigzag pivot directions (Lower High : 1, Higher High : 2, Lower Low : -2 and Higher Low : -1)
//          zigzagpivotratios   : Array containing zigzag retracement ratios for each pivot
//          zigzagoscillators   : Array of oscillator values at pivots. Will have valid values only if valid oscillatorSource is provided as per input.
//          zigzagoscillatordirs: Array of oscillator directions (HH, HL, LH, LL) at pivots. Will have valid values only if valid oscillatorSource is provided as per input.
//          zigzagtrendbias     : Array of trend bias at pivots. Will have valid value only if directionBias series is sent in input parameters
//          zigzagdivergence    :   Array of divergence sentiment at each pivot. Will have valid values only if oscillatorSource and directionBias inputs are provided
//          newPivot            : Returns true if new pivot created
//          doublePivot         : Returns true if two new pivots are created on same bar (Happens in case of candles with long wicks and shorter zigzag lengths)
zigzag(int length, simple int numberOfPivots = 20, simple bool useAlternativeSource = false, float source=close, 
         float oscillatorSource = close, float oscillatorHighSource = high, float oscillatorLowSource  = close, int directionBias = 1, int divergenceOption=1) =>
    var zigzagpivots = array.new_float(0)
    var zigzagpivotbars = array.new_int(0)
    var zigzagpivotdirs = array.new_int(0)
    var zigzagpivotratios = array.new_float(0)
    var zigzagoscillators = array.new_float(0)
    var zigzagoscillatordirs = array.new_int(0)
    var zigzagtrendbias = array.new_int(0)
    var zigzagdivergence = array.new_int(0)
    var zigzagdoubledivergence = array.new_int(0)
    oscHigh = not useAlternativeSource and oscillatorHighSource!= source? oscillatorHighSource : oscillatorSource
    oscLow = not useAlternativeSource and oscillatorLowSource != source? oscillatorLowSource : oscillatorSource
    highSource = useAlternativeSource ? source : high
    lowSource = useAlternativeSource ? source : low
    [phigh, plow, phighbar, plowbar] = pivots(length, highSource, lowSource)
    [newPivot, doublePivot] = zigzagcore(phigh, plow, phighbar, plowbar, numberOfPivots,
                                     oscHigh, oscLow, directionBias,
                                     zigzagpivots, zigzagpivotbars, zigzagpivotdirs, zigzagpivotratios, zigzagoscillators,
                                     zigzagoscillatordirs, zigzagtrendbias, zigzagdivergence, zigzagdoubledivergence, divergenceOption)
    [zigzagpivots, zigzagpivotbars, zigzagpivotdirs, zigzagpivotratios, zigzagoscillators,
                                     zigzagoscillatordirs, zigzagtrendbias, zigzagdivergence, zigzagdoubledivergence,
                                     newPivot, doublePivot]


// @function czigzag: Calculates zigzag pivots and generates an array based on custom high and low source
// @param   length                  : Zigzag Length
// @param   numberOfPivots          : Max number of pivots to return in the array. Default is 20
// @param   highSource              : High Source for prices to calculate zigzag.
// @param   lowSource               : Low source for prices to calculate zigzag.
// @param   oscillatorHighSource    : Oscillator high source for calculating divergence
// @param   oscillatorLowSource     : Oscillator high source for calculating divergence
// @param   directionBias           : Direction bias for calculating divergence
// @param   divergenceOption        : 1 - hidden/regular, 2 - regular, 3 - hidden
// @returns zigzagpivots        : Array containing zigzag pivots
//          zigzagpivotbars     : Array containing zigzag pivot bars
//          zigzagpivotdirs     : Array containing zigzag pivot directions (Lower High : 1, Higher High : 2, Lower Low : -2 and Higher Low : -1)
//          zigzagpivotratios   : Array containing zigzag retracement ratios for each pivot
//          zigzagoscillators   : Array of oscillator values at pivots. Will have valid values only if valid oscillatorSource is provided as per input.
//          zigzagoscillatordirs: Array of oscillator directions (HH, HL, LH, LL) at pivots. Will have valid values only if valid oscillatorSource is provided as per input.
//          zigzagtrendbias     : Array of trend bias at pivots. Will have valid value only if directionBias series is sent in input parameters
//          zigzagdivergence    :   Array of divergence sentiment at each pivot. Will have valid values only if oscillatorSource and directionBias inputs are provided
//          zigzagdoubledivergence : Array of double divergence sentiment at each pivot
//          newPivot            : Returns true if new pivot created
//          doublePivot         : Returns true if two new pivots are created on same bar (Happens in case of candles with long wicks and shorter zigzag lengths)
czigzag(int length, simple int numberOfPivots = 20, float highSource = high, float lowSource = low, 
                 float oscillatorHighSource = high, float oscillatorLowSource  = low, int directionBias = 1, int divergenceOption=1) =>
    var zigzagpivots = array.new_float(0)
    var zigzagpivotbars = array.new_int(0)
    var zigzagpivotdirs = array.new_int(0)
    var zigzagpivotratios = array.new_float(0)
    var zigzagoscillators = array.new_float(0)
    var zigzagoscillatordirs = array.new_int(0)
    var zigzagtrendbias = array.new_int(0)
    var zigzagdivergence = array.new_int(0)
    var zigzagdoubledivergence = array.new_int(0)
    [phigh, plow, phighbar, plowbar] = pivots(length, highSource, lowSource)
    [newPivot, doublePivot] = zigzagcore(phigh, plow, phighbar, plowbar, numberOfPivots,
                                     oscillatorHighSource, oscillatorLowSource, directionBias,
                                     zigzagpivots, zigzagpivotbars, zigzagpivotdirs, zigzagpivotratios, zigzagoscillators,
                                     zigzagoscillatordirs, zigzagtrendbias, zigzagdivergence, zigzagdoubledivergence, divergenceOption)
    [zigzagpivots, zigzagpivotbars, zigzagpivotdirs, zigzagpivotratios, zigzagoscillators,
                                     zigzagoscillatordirs, zigzagtrendbias, zigzagdivergence, zigzagdoubledivergence,
                                     newPivot, doublePivot]


// @function drawczigzag: Calculates and draws zigzag pivots and generates an array based on custom high and low source
// @param   length                  : Zigzag Length
// @param   numberOfPivots          : Max number of pivots to return in the array. Default is 20
// @param   highSource              : High Source for prices to calculate zigzag.
// @param   lowSource               : Low source for prices to calculate zigzag.
// @param   oscillatorHighSource    : Oscillator high source for calculating divergence
// @param   oscillatorLowSource     : Oscillator high source for calculating divergence
// @param   directionBias           : Direction bias for calculating divergence
// @param   showHighLow             : show highlow label
// @param   showRatios              : show retracement ratios
// @param   showDivergence          : Show divergence on label (Only works if divergence data is available - that is if we pass valid oscillatorSource and directionBias input)
// @param   showDoubleDivergence    : Show double divergence label
// @param   linecolor               : zigzag line color
// @param   linewidth               : zigzag line width
// @param   linestyle               : zigzag line style
// @returns zigzagpivots        : Array containing zigzag pivots
//          zigzagpivotbars     : Array containing zigzag pivot bars
//          zigzagpivotdirs     : Array containing zigzag pivot directions (Lower High : 1, Higher High : 2, Lower Low : -2 and Higher Low : -1)
//          zigzagpivotratios   : Array containing zigzag retracement ratios for each pivot
//          zigzagoscillators   : Array of oscillator values at pivots. Will have valid values only if valid oscillatorSource is provided as per input.
//          zigzagoscillatordirs: Array of oscillator directions (HH, HL, LH, LL) at pivots. Will have valid values only if valid oscillatorSource is provided as per input.
//          zigzagtrendbias     : Array of trend bias at pivots. Will have valid value only if directionBias series is sent in input parameters
//          zigzagdivergence    :   Array of divergence sentiment at each pivot. Will have valid values only if oscillatorSource and directionBias inputs are provided
//          zigzagdoubledivergence : Array of double divergence sentiment at each pivot
//          zigzaglines         : Returns array of zigzag lines
//          zigzaglabels        : Returns array of zigzag labels
drawczigzag(int length, simple int numberOfPivots = 20, float highSource = high, float lowSource = low, 
                 float oscillatorHighSource = high, float oscillatorLowSource  = low, int directionBias = 1, 
                 simple bool showHighLow=false, simple bool showRatios = false, simple bool showDivergence = false, 
                 simple bool showDoubleDivergence = false, simple bool showIndicator = false, 
                 color linecolor = color.blue, int linewidth = 1, string linestyle = line.style_solid)=>
    [zigzagpivots, zigzagpivotbars, zigzagpivotdirs, zigzagpivotratios, zigzagoscillators,
                                 zigzagoscillatordirs, zigzagtrendbias, zigzagdivergence, zigzagdoubledivergence,
                                 newPivot, doublePivot] = czigzag(length, numberOfPivots, highSource, lowSource, oscillatorHighSource, oscillatorLowSource, directionBias)
    var zigzaglines = array.new_line(0)
    var zigzaglabels = array.new_label(0)
    if(newPivot)
        if doublePivot
            draw_zg_line2(1, 2, zigzaglines, zigzaglabels, zigzagpivots, zigzagpivotbars, zigzagpivotdirs, 
                             zigzagpivotratios, zigzagoscillators, zigzagdivergence, zigzagdoubledivergence,
                             linecolor, linewidth, linestyle, showHighLow, showRatios, showDivergence, showDoubleDivergence, showIndicator)

        if array.size(zigzagpivots) >= 2
            draw_zg_line2(0, 1, zigzaglines, zigzaglabels, zigzagpivots, zigzagpivotbars, zigzagpivotdirs,
                             zigzagpivotratios, zigzagoscillators, zigzagdivergence, zigzagdoubledivergence,
                             linecolor, linewidth, linestyle, showHighLow, showRatios, showDivergence, showDoubleDivergence, showIndicator)
    [zigzagpivots, zigzagpivotbars, zigzagpivotdirs, zigzagpivotratios, zigzagoscillators,
                                     zigzagoscillatordirs, zigzagtrendbias, zigzagdivergence, zigzagdoubledivergence,
                                     zigzaglines, zigzaglabels]


// @function drawczigzag2: Same as drawczigzag. But, returns newPivot and doublePivot bools as well.
// @param   length                  : Zigzag Length
// @param   numberOfPivots          : Max number of pivots to return in the array. Default is 20
// @param   highSource              : High Source for prices to calculate zigzag.
// @param   lowSource               : Low source for prices to calculate zigzag.
// @param   oscillatorHighSource    : Oscillator high source for calculating divergence
// @param   oscillatorLowSource     : Oscillator high source for calculating divergence
// @param   directionBias           : Direction bias for calculating divergence
// @param   showHighLow             : show highlow label
// @param   showRatios              : show retracement ratios
// @param   showDivergence          : Show divergence on label (Only works if divergence data is available - that is if we pass valid oscillatorSource and directionBias input)
// @param   showDoubleDivergence    : Show double divergence label
// @param   linecolor               : zigzag line color
// @param   linewidth               : zigzag line width
// @param   linestyle               : zigzag line style
// @returns zigzagpivots        : Array containing zigzag pivots
//          zigzagpivotbars     : Array containing zigzag pivot bars
//          zigzagpivotdirs     : Array containing zigzag pivot directions (Lower High : 1, Higher High : 2, Lower Low : -2 and Higher Low : -1)
//          zigzagpivotratios   : Array containing zigzag retracement ratios for each pivot
//          zigzagoscillators   : Array of oscillator values at pivots. Will have valid values only if valid oscillatorSource is provided as per input.
//          zigzagoscillatordirs: Array of oscillator directions (HH, HL, LH, LL) at pivots. Will have valid values only if valid oscillatorSource is provided as per input.
//          zigzagtrendbias     : Array of trend bias at pivots. Will have valid value only if directionBias series is sent in input parameters
//          zigzagdivergence    :   Array of divergence sentiment at each pivot. Will have valid values only if oscillatorSource and directionBias inputs are provided
//          zigzagdoubledivergence : Array of double divergence sentiment at each pivot
//          zigzaglines         : Returns array of zigzag lines
//          zigzaglabels        : Returns array of zigzag labels
drawczigzag2(int length, simple int numberOfPivots = 20, float highSource = high, float lowSource = low, 
                 float oscillatorHighSource = high, float oscillatorLowSource  = low, int directionBias = 1, 
                 simple bool showHighLow=false, simple bool showRatios = false, simple bool showDivergence = false, 
                 simple bool showDoubleDivergence = false, simple bool showIndicator = false, 
                 color linecolor = color.blue, int linewidth = 1, string linestyle = line.style_solid)=>
    [zigzagpivots, zigzagpivotbars, zigzagpivotdirs, zigzagpivotratios, zigzagoscillators,
                                 zigzagoscillatordirs, zigzagtrendbias, zigzagdivergence, zigzagdoubledivergence,
                                 newPivot, doublePivot] = czigzag(length, numberOfPivots, highSource, lowSource, oscillatorHighSource, oscillatorLowSource, directionBias)
    var zigzaglines = array.new_line(0)
    var zigzaglabels = array.new_label(0)
    if(newPivot)
        if doublePivot
            draw_zg_line2(1, 2, zigzaglines, zigzaglabels, zigzagpivots, zigzagpivotbars, zigzagpivotdirs, 
                             zigzagpivotratios, zigzagoscillators, zigzagdivergence, zigzagdoubledivergence,
                             linecolor, linewidth, linestyle, showHighLow, showRatios, showDivergence, showDoubleDivergence, showIndicator)

        if array.size(zigzagpivots) >= 2
            draw_zg_line2(0, 1, zigzaglines, zigzaglabels, zigzagpivots, zigzagpivotbars, zigzagpivotdirs,
                             zigzagpivotratios, zigzagoscillators, zigzagdivergence, zigzagdoubledivergence,
                             linecolor, linewidth, linestyle, showHighLow, showRatios, showDivergence, showDoubleDivergence, showIndicator)
    [zigzagpivots, zigzagpivotbars, zigzagpivotdirs, zigzagpivotratios, zigzagoscillators,
                                     zigzagoscillatordirs, zigzagtrendbias, zigzagdivergence, zigzagdoubledivergence,
                                     newPivot, doublePivot, zigzaglines, zigzaglabels]
                                     
// @function drawzigzag: Calculates and draws zigzag pivots
// @param   length              : Zigzag Length
// @param   numberOfPivots      : Max number of pivots to return in the array. Default is 20
// @param   useAlternativeSource: If set uses the source for genrating zigzag. Default is false
// @param   source              : Alternative source used only if useAlternativeSource is set to true. Default is close
// @param   linecolor           : zigzag line color
// @param   linewidth           : zigzag line width
// @param   linestyle           : zigzag line style
// @param   oscillatorSource    : Oscillator source for calculating divergence
// @param   directionBias       : Direction bias for calculating divergence
// @param   showHighLow         : show highlow label
// @param   showRatios          : show retracement ratios
// @param   showDivergence      : Show divergence on label (Only works if divergence data is available - that is if we pass valid oscillatorSource and directionBias input)
// @returns zigzagpivots        : Array containing zigzag pivots
//          zigzagpivotbars     : Array containing zigzag pivot bars
//          zigzagpivotdirs     : Array containing zigzag pivot directions (Lower High : 1, Higher High : 2, Lower Low : -2 and Higher Low : -1)
//          zigzagpivotratios   : Array containing zigzag retracement ratios for each pivot
//          zigzagoscillators   : Array of oscillator values at pivots. Will have valid values only if valid oscillatorSource is provided as per input.
//          zigzagoscillatordirs: Array of oscillator directions (HH, HL, LH, LL) at pivots. Will have valid values only if valid oscillatorSource is provided as per input.
//          zigzagtrendbias     : Array of trend bias at pivots. Will have valid value only if directionBias series is sent in input parameters
//          zigzagdivergence    :   Array of divergence sentiment at each pivot. Will have valid values only if oscillatorSource and directionBias inputs are provided
//          zigzaglines         : Returns array of zigzag lines
//          zigzaglabels        : Returns array of zigzag labels
drawzigzag(int length, simple int numberOfPivots = 20, simple bool useAlternativeSource = false, float source=close,
                     color linecolor = color.blue, int linewidth = 1, string linestyle = line.style_solid,
                     float oscillatorSource = close,  float oscillatorHighSource = high, float oscillatorLowSource = close, int directionBias = 1,
                     simple bool showHighLow=false, simple bool showRatios = false, simple bool showDivergence = false)=>
    [zigzagpivots, zigzagpivotbars, zigzagpivotdirs, zigzagpivotratios, zigzagoscillators,
                                     zigzagoscillatordirs, zigzagtrendbias, zigzagdivergence, zigzagdoubledivergence,
                                     newPivot, doublePivot] = zigzag(length, numberOfPivots, useAlternativeSource, source, 
                                                                     oscillatorSource, oscillatorHighSource, oscillatorLowSource, directionBias)
    var zigzaglines = array.new_line(0)
    var zigzaglabels = array.new_label(0)
    if(newPivot)
        if doublePivot
            draw_zg_line(1, 2, zigzaglines, zigzaglabels, zigzagpivots, zigzagpivotbars, zigzagpivotdirs, zigzagpivotratios, zigzagdivergence,
                             linecolor, linewidth, linestyle, showHighLow, showRatios, showDivergence)

        if array.size(zigzagpivots) >= 2
            draw_zg_line(0, 1, zigzaglines, zigzaglabels, zigzagpivots, zigzagpivotbars, zigzagpivotdirs, zigzagpivotratios, zigzagdivergence,
                             linecolor, linewidth, linestyle, showHighLow, showRatios, showDivergence)
    [zigzagpivots, zigzagpivotbars, zigzagpivotdirs, zigzagpivotratios, zigzagoscillators,
                                     zigzagoscillatordirs, zigzagtrendbias, zigzagdivergence, 
                                     zigzaglines, zigzaglabels]


// ************************************************************* Demonstrating usage examples *************************************************************/
operation = input.string("Draw Zigzag", "Operation", options=["Draw Zigzag", "Get Zigzag"], group="Zigzag", inline="z")
zigzagLength = input.int(5, "", group="Zigzag", inline="z")
useAlternativeSource = input.bool(false, "Use Alternative Source", group="Alternate Source", inline="s")
source = input.source(close, "", group="Alternate Source", inline="s")

useDifferentLineStyle = input.bool(false, "Use Different Line Style", group="Line Style", inline="l")
linecolor = input.color(color.maroon, "", group="Line Style", inline="l")
linewidth = input.int(3, "", group="Line Style", inline="l")
linestyle = input.string(line.style_dashed, "", options=[line.style_solid, line.style_dashed, line.style_dotted], group="Line Style", inline="l")
showHighLow = input.bool(false, "HHLL", group="Display Labels", inline="lb")
showRatios = input.bool(false, "Ratios", group="Display Labels", inline="lb")
showOscillator = input.bool(false, "Oscillator", group="Display Labels", inline="lb")
showDivergence = input.bool(false, "Divergence", group="Display Labels", inline="lb")
showDoubleDivergence = input.bool(false, "Double Divergence", group="Display Labels", inline="lb")

if(operation == "Draw Zigzag")
    rsi = ta.rsi(close, 14)
    rsiHigh = ta.rsi(high, 14)
    rsiLow = ta.rsi(low, 14)
    [supertrend, dir] = ta.supertrend(4, 22)
    directionBias = int(-dir)
    if(not useDifferentLineStyle)
        drawczigzag(zigzagLength, highSource=high, lowSource=low,
                         oscillatorHighSource=rsiHigh, oscillatorLowSource=rsiLow, directionBias = directionBias,
                         showHighLow=showHighLow, showRatios=showRatios, showDivergence=showDivergence, showDoubleDivergence=showDoubleDivergence, showIndicator=showOscillator)
    else
        drawczigzag(zigzagLength, highSource=high, lowSource=low,
                         linecolor=linecolor, linewidth = linewidth, linestyle = linestyle,
                         oscillatorHighSource=rsiHigh, oscillatorLowSource=rsiLow, directionBias = directionBias,
                         showHighLow=showHighLow, showRatios=showRatios, showDivergence=showDivergence, showDoubleDivergence=showDoubleDivergence, showIndicator=showOscillator)

else
    // Plain zigzag when nothing is selected
    if(not useAlternativeSource and not showDivergence)
        [zigzagpivots, zigzagpivotbars, zigzagpivotdirs, zigzagpivotratios, zigzagoscillators,
                                     zigzagoscillatordirs, zigzagtrendbias, zigzagdivergence, zigzagdoubledivergence,
                                     newPivot, doublePivot] = zigzag(zigzagLength)
    
    // When using Alternate source
    else if(useAlternativeSource and not showDivergence)
        [zigzagpivots, zigzagpivotbars, zigzagpivotdirs, zigzagpivotratios, zigzagoscillators,
                                     zigzagoscillatordirs, zigzagtrendbias, zigzagdivergence, zigzagdoubledivergence,
                                     newPivot, doublePivot] = zigzag(zigzagLength, useAlternativeSource=useAlternativeSource, source = source)
        
    // When divergence is included
    else 
        //Calculating Oscillator and direction bias for divergence
        rsi = ta.rsi(close, 14)
        [supertrend, dir] = ta.supertrend(4, 22)
        directionBias = int(-dir)
        [zigzagpivots, zigzagpivotbars, zigzagpivotdirs, zigzagpivotratios, zigzagoscillators,
                                     zigzagoscillatordirs, zigzagtrendbias, zigzagdivergence, zigzagdoubledivergence,
                                     newPivot, doublePivot] = zigzag(zigzagLength, useAlternativeSource=useAlternativeSource, source = source,
                                                                 oscillatorSource=rsi, directionBias = directionBias)
    false

import HeWhoMustNotBeNamed/arrayutils/17 as pa
//----------------------EHANCED TA CODE
bandwidth(float middle, float upper, float lower)=> 100*(upper-lower)/middle
percentb(float source, float upper, float lower)=> 100*(source-lower)/(upper-lower)
customseries(float source=close, simple string type="sma", simple int length) =>
    switch type
    	"ema" => ta.ema(source, length)
    	"sma" => ta.sma(source, length)
    	"rma" => ta.rma(source, length)
    	"hma" => ta.hma(source, length)
    	"wma" => ta.wma(source, length)
    	"vwma" => ta.vwma(source, length)
    	"swma" => ta.swma(source)
    	"linreg" => ta.linreg(source, length, 0)
    	"median" => ta.median(source, length)
    	"mom" => ta.mom(source, length)
    	"high" => ta.highest(source, length)
    	"low" => ta.lowest(source, length)
    	"medianHigh" => ta.median(ta.highest(source, length), length)
    	"medianLow" => ta.median(ta.lowest(source, length), length)
    	"percentrank" => ta.percentrank(source, length)
    	=> (ta.highest(length) + ta.lowest(length))/2


getStickyRange(float highsource, float lowsource, float upper, float lower, simple bool sticky=false)=>
    newUpper = upper
    newLower = lower
    highBreakout = highsource[1] >= newUpper[1]
    lowBreakout = lowsource[1] <= newLower[1]
    newUpper := (highBreakout or lowBreakout or not sticky)? newUpper : nz(newUpper[1], newUpper)
    newLower := (highBreakout or lowBreakout or not sticky)? newLower : nz(newLower[1], newLower)
    [newUpper, newLower]

// @function returns custom moving averages
// @param source Moving Average Source
// @param maType Moving Average Type : Can be sma, ema, hma, rma, wma, vwma, swma, highlow, linreg, median
// @param length Moving Average Length
// @returns moving average for the given type and length
ma(float source=close, simple string maType="sma", simple int length) =>
    customseries(source, maType, length)

// @function returns ATR with custom moving average
// @param maType Moving Average Type : Can be sma, ema, hma, rma, wma, vwma, swma, highlow, linreg, median
// @param length Moving Average Length
// @returns ATR for the given moving average type and length
atr(simple string maType="sma", simple int length) =>
    customseries(ta.tr, maType, length)

// @function returns ATR as percentage of close price
// @param maType Moving Average Type : Can be sma, ema, hma, rma, wma, vwma, swma, highlow, linreg, median
// @param length Moving Average Length
// @returns ATR as percentage of close price for the given moving average type and length
atrpercent(simple string maType="sma", simple int length) =>
    100*atr(maType, length)/close

// @function returns Bollinger band for custom moving average
// @param source Moving Average Source
// @param maType Moving Average Type : Can be sma, ema, hma, rma, wma, vwma, swma, highlow, linreg, median
// @param length Moving Average Length
// @param multiplier Standard Deviation multiplier
// @param sticky - sticky boundaries which will only change when value is outside boundary.
// @returns Bollinger band with custom moving average for given source, length and multiplier
bb(float source=close, simple string maType="sma", simple int length=20, float multiplier=2.0, simple bool sticky=false) =>
    float middle = ma(source, maType, length)
	float upper = middle + ta.stdev(source, length)*multiplier
	float lower = middle - ta.stdev(source, length)*multiplier
	[newUpper, newLower] = getStickyRange(high, low, upper, lower, sticky)
	upper := newUpper
	lower := newLower
	[middle, upper, lower]

// @function returns Bollinger bandwidth for custom moving average
// @param source Moving Average Source
// @param maType Moving Average Type : Can be sma, ema, hma, rma, wma, vwma, swma, highlow, linreg, median
// @param length Moving Average Length
// @param multiplier Standard Deviation multiplier
// @param sticky - sticky boundaries which will only change when value is outside boundary.
// @returns Bollinger Bandwidth for custom moving average for given source, length and multiplier
bbw(float source=close, simple string maType="sma", simple int length=20, float multiplier=2.0, simple bool sticky=false) =>
    [middle, upper, lower] = bb(source, maType, length, multiplier, sticky)
    bandwidth(middle, upper, lower)
    
// @function returns Bollinger Percent B for custom moving average
// @param source Moving Average Source
// @param maType Moving Average Type : Can be sma, ema, hma, rma, wma, vwma, swma, highlow, linreg, median
// @param length Moving Average Length
// @param multiplier Standard Deviation multiplier
// @param sticky - sticky boundaries which will only change when value is outside boundary.
// @returns Bollinger Percent B for custom moving average for given source, length and multiplier
bpercentb(float source=close, simple string maType="sma", simple int length=20, float multiplier=2.0, simple bool sticky=false) =>
    [middle, upper, lower] = bb(source, maType, length, multiplier, sticky)
    percentb(source, upper, lower)
    

// @function returns Keltner Channel for custom moving average
// @param source Moving Average Source
// @param maType Moving Average Type : Can be sma, ema, hma, rma, wma, vwma, swma, highlow, linreg, median
// @param length Moving Average Length
// @param multiplier Standard Deviation multiplier
// @param useTrueRange - if set to false, uses high-low.
// @param sticky - sticky boundaries which will only change when value is outside boundary.
// @returns Keltner Channel for custom moving average for given souce, length and multiplier
kc(float source=close, simple string maType="ema", simple int length=20, float multiplier=2, simple bool useTrueRange=true, simple bool sticky=false) =>
    float middle = ma(source, maType, length)
	float span = (useTrueRange) ? ta.tr : (high - low)
	float rangeMa = ma(span, maType, length)
	float upper = middle + rangeMa*multiplier
	float lower = middle - rangeMa*multiplier
	[newUpper, newLower] = getStickyRange(high, low, upper, lower, sticky)
	upper := newUpper
	lower := newLower
	[middle, upper, lower]
	
	
// @function returns Keltner Channel Width with custom moving average
// @param source Moving Average Source
// @param maType Moving Average Type : Can be sma, ema, hma, rma, wma, vwma, swma, highlow, linreg, median
// @param length Moving Average Length
// @param multiplier Standard Deviation multiplier
// @param useTrueRange - if set to false, uses high-low.
// @param sticky - sticky boundaries which will only change when value is outside boundary.
// @returns Keltner Channel Width for custom moving average
kcw(float source=close, simple string maType="ema", simple int length=20, float multiplier=2, simple bool useTrueRange=true, simple bool sticky=false) =>
    [middle, upper, lower] = kc(source, maType, length, multiplier, useTrueRange, sticky)
    bandwidth(middle, upper, lower)
    

// @function returns Keltner Channel Percent K Width with custom moving average
// @param source Moving Average Source
// @param maType Moving Average Type : Can be sma, ema, hma, rma, wma, vwma, swma, highlow, linreg, median
// @param length Moving Average Length
// @param multiplier Standard Deviation multiplier
// @param useTrueRange - if set to false, uses high-low.
// @param sticky - sticky boundaries which will only change when value is outside boundary.
// @returns Keltner Percent K for given moving average, source, length and multiplier
kpercentk(float source=close, simple string maType="ema", simple int length=20, float multiplier=2, simple bool useTrueRange=true, simple bool sticky=false) =>
    [middle, upper, lower] = kc(source, maType, length, multiplier, useTrueRange, sticky)
    percentb(source, upper, lower)
    

// @function returns Custom Donchian Channel
// @param length - donchian channel length
// @param useAlternateSource - Custom source is used only if useAlternateSource is set to true
// @param alternateSource - Custom source
// @param sticky - sticky boundaries which will only change when value is outside boundary.
// @returns Donchian channel
dc(simple int length=20, simple bool useAlternateSource = false, float alternateSource = close, simple bool sticky=false) =>
    highSource = useAlternateSource? alternateSource : high
    lowSource = useAlternateSource? alternateSource : low
    [upper, lower] = getStickyRange(highSource, lowSource, ta.highest(highSource, length), ta.lowest(lowSource, length), sticky)
    middle = (upper+lower)/2
    [middle, upper, lower]


// @function returns Donchian Channel Width
// @param length - donchian channel length
// @param useAlternateSource - Custom source is used only if useAlternateSource is set to true
// @param alternateSource - Custom source
// @param sticky - sticky boundaries which will only change when value is outside boundary.
// @returns Donchian channel width
dcw(simple int length=20, simple bool useAlternateSource = false, float alternateSource = close, simple bool sticky=false) =>
    [middle, upper, lower] = dc(length, useAlternateSource, alternateSource, sticky)
    bandwidth(middle, upper, lower)
    

// @function returns Donchian Channel Percent of price
// @param useAlternateSource - Custom source is used only if useAlternateSource is set to true
// @param alternateSource - Custom source
// @param length - donchian channel length
// @param sticky - sticky boundaries which will only change when value is outside boundary.
// @returns Donchian channel Percent D
dpercentd(simple int length=20, simple bool useAlternateSource = false, float alternateSource = close, simple bool sticky=false) =>
    [middle, upper, lower] = dc(length, useAlternateSource, alternateSource, sticky)
    percentb(useAlternateSource? alternateSource : hl2, upper, lower)

// @function oscillatorRange - returns Custom overbought/oversold areas for an oscillator input
// @param source - Osillator source such as RSI, COG etc.
// @param method - Valid values for method are : sma, ema, hma, rma, wma, vwma, swma, highlow, linreg, median
// @param highlowLength - length on which highlow of the oscillator is calculated
// @param rangeLength - length used for calculating oversold/overbought range - usually same as oscillator length
// @param sticky - overbought, oversold levels won't change unless crossed
// @returns Dynamic overbought and oversold range for oscillator input
oscillatorRange(float source, simple string method="highlow", simple int highlowLength=50, simple int rangeLength=14, simple bool sticky=false) =>
    oscillatorHighest = customseries(source, "high", highlowLength)
    oscillatorLowest = customseries(source, "low", highlowLength)
    
    oscOverbought = customseries(oscillatorHighest, method == "highlow"? "low" : method, rangeLength)
    oscOversold = customseries(oscillatorLowest, method == "highlow"? "high" : method, rangeLength)

    getStickyRange(source, source, oscOverbought, oscOversold, sticky)

// @function oscillator - returns Choice of oscillator with custom overbought/oversold range
// @param type - oscillator type. Valid values : cci, cmo, cog, mfi, roc, rsi, stoch, tsi, wpr
// @param length - Oscillator length - not used for TSI
// @param shortLength - shortLength only used for TSI
// @param longLength - longLength only used for TSI
// @param source - custom source if required
// @param highSource - custom high source for stochastic oscillator
// @param lowSource - custom low source for stochastic oscillator
// @param method - Valid values for method are : sma, ema, hma, rma, wma, vwma, swma, highlow, linreg, median
// @param highlowLength - length on which highlow of the oscillator is calculated
// @param sticky - overbought, oversold levels won't change unless crossed
// @returns Oscillator value along with dynamic overbought and oversold range for oscillator input
oscillator(simple string type="rsi", simple int length=14, simple int shortLength = 13, simple int longLength = 25,
                     float source = close, float highSource = high, float lowSource = low,
                     simple string method="highlow", simple int highlowLength=50, simple bool sticky=false)=>
    oscillator =  switch type
        "cci" => ta.cci(source, length)
    	"cmo" => ta.cmo(source, length)
    	"cog" => ta.cog(source, length)
    	"mfi" => ta.mfi(source, length)
    	"roc" => ta.roc(source, length)
    	"rsi" => ta.rsi(source, length)
    	"stoch" => ta.stoch(source, highSource, lowSource, length)
    	"tsi" => ta.tsi(source, shortLength, longLength)
    	"wpr" => ta.wpr(length)
    	=> ta.rsi(source, length)

    [overbought, oversold] = oscillatorRange(oscillator, method, highlowLength, length, sticky)
    [oscillator, overbought, oversold]
    

// @function multibands - returns Choice of oscillator with custom overbought/oversold range
// @param bandType - Band type - can be either bb or kc
// @param source - custom source if required
// @param maType Moving Average Type : Can be sma, ema, hma, rma, wma, vwma, swma, highlow, linreg, median
// @param length - Oscillator length - not used for TSI
// @param useTrueRange - if set to false, uses high-low.
// @param sticky - for sticky borders which only change upon source crossover/crossunder
// @param numberOfBands - Number of bands to generate
// @param multiplierStart - Starting ATR or Standard deviation multiplier for first band
// @param multiplierStep - Incremental value for multiplier for each band
// @returns array of band values sorted in ascending order
multibands(simple string bandType="bb", float source=close, simple string maType = "sma", simple int length = 60, 
         simple bool useTrueRange=true, simple bool sticky=false,
         simple int numberOfBands=7, simple float multiplierStart = 0.5, simple float multiplierStep = 0.5)=>
    bands = array.new_float()
    for i=0 to numberOfBands-1
        multiplier = multiplierStart + i*multiplierStep
        middle = 0.0
        upper = 0.0
        lower = 0.0
        if(bandType == "bb")
            [bbmiddle, bbupper, bblower] = bb(source, maType, length, multiplier, sticky)
            middle := bbmiddle
            upper := bbupper
            lower := bblower
        else
            [kcmiddle, kcupper, kclower] = kc(source, maType, length, multiplier, useTrueRange, sticky)
            middle := kcmiddle
            upper := kcupper
            lower := kclower
        array.unshift(bands, lower)
        array.unshift(bands, upper)
        if(i == 0)
            array.unshift(bands, middle)
    array.sort(bands)
    bands

// @function mbandoscillator - Multiband oscillator created on the basis of bands
// @param bandType - Band type - can be either bb or kc
// @param source - custom source if required
// @param maType Moving Average Type : Can be sma, ema, hma, rma, wma, vwma, swma, highlow, linreg, median
// @param length - Oscillator length - not used for TSI
// @param useTrueRange - if set to false, uses high-low.
// @param stickyBands - for sticky borders which only change upon source crossover/crossunder for band detection
// @param numberOfBands - Number of bands to generate
// @param multiplierStart - Starting ATR or Standard deviation multiplier for first band
// @param multiplierStep - Incremental value for multiplier for each band
// @returns oscillator currentStates - Array containing states for last n bars
mbandoscillator(simple string bandType="kc", float source=close, simple string maType = "sma", simple int length = 60, 
         simple bool useTrueRange=false, simple bool stickyBands=false,
         simple int numberOfBands=100, simple float multiplierStart = 0.5, simple float multiplierStep = 0.5
         )=>

    states = multibands(bandType, source, maType, length, useTrueRange, stickyBands, numberOfBands, multiplierStart, multiplierStep)
    currentState = array.size(states)
    for i = 0 to array.size(states) - 1 by 1
        if source < array.get(states, i)
            currentState := i
            break
    currentState

// @function finds difference between two timestamps
// @param timeStart - start timestamp
// @param endTime - end timestamp
timer(int timeStart, int timeEnd=timenow)=>
    timeDiff = math.abs(timeEnd - timeStart)
    mseconds = timeDiff
    seconds = mseconds/1000
    minutes = seconds/60
    hours = minutes/60
    days = hours/24
    
    tmSeconds = mseconds%1000
    tSeconds = seconds%60
    tMinutes = minutes%60
    tHours = hours%24
    [days, tHours, tMinutes, tSeconds, tmSeconds]
    
//******************************************** USAGE ****************************************** //
display = input.string("multibands", title="Display Indicator", options=["all", "ma", "atr", "multibands",
                                                                     "band", "bandwidth", "bandpercent","oscillator"])
overlay = input.bool(true, title="Overlay", inline="o")
nonOverlay = input.bool(true, title="NonOverlay", inline="o")
//************************************ ma *************************************************** //
masource = input.source(close, title="Source", group="Moving Average")
matype = input.string("sma", title="Type", group="Moving Average", options=["sma", "ema", "hma", "rma", "wma", "vwma", "swma", "linreg", "median"])
malength = input.int(20, title="Length", group="Moving Average")

_ma = ma(masource, matype, malength)
displayMa = display == "ma" or (display == "all" and overlay)
// plot(displayMa? _ma : na, title="Moving Average", color=color.blue)

//************************************ ATR *************************************************** //
amatype = input.string("sma", title="Type", group="ATR", options=["sma", "ema", "hma", "rma", "wma", "vwma", "swma", "linreg", "median"])
amalength = input.int(20, title="Length", group="ATR")
displayPercent = input.bool(false, title="Display as Percent", group="ATR")
_atr = atr(amatype, amalength)
_atrpercent = atrpercent(amatype, amalength)
displayAtr = display == "atr" or (display == "all" and nonOverlay)
// plot(displayAtr? displayPercent? _atrpercent : _atr : na, title="ATR (or Percent)", color = color.blue)
//************************************ bands *************************************************** //
bandType = input.string("BB", title="Type", group="Bands/Bandwidth/BandPercent", options=["BB", "KC", "DC"])
bmasource = input.source(close, title="Source", group="Bands/Bandwidth/BandPercent")
bmatype = input.string("sma", title="Type", group="Bands/Bandwidth/BandPercent", options=["sma", "ema", "hma", "rma", "wma", "vwma", "swma", "linreg", "median"])
bmalength = input.int(20, title="Length", group="Bands/Bandwidth/BandPercent")
multiplier = input.float(2.0, step=0.5, title="Multiplier", group="Bands/Bandwidth/BandPercent")
useTrueRange = input.bool(true, title="Use True Range (KC)", group="Bands/Bandwidth/BandPercent")
useAlternateSource = input.bool(false, title="Use Alternate Source (DC)", group="Bands/Bandwidth/BandPercent")
bsticky = input.bool(true, title="Sticky", group="Bands/Bandwidth/BandPercent")

displayBands = display == "band" or (display == "all" and overlay)
var cloudTransparency = 90
[bbmiddle, bbupper, bblower] = bb(bmasource, bmatype, bmalength, multiplier, sticky=bsticky)
[kcmiddle, kcupper, kclower] = kc(bmasource, bmatype, bmalength, multiplier, useTrueRange, sticky=bsticky)
[dcmiddle, dcupper, dclower] = dc(bmalength, useAlternateSource, bmasource, sticky=bsticky)

upper = bandType == "BB"? bbupper : bandType == "KC"? kcupper : dcupper
lower = bandType == "BB"? bblower : bandType == "KC"? kclower : dclower
middle = bandType == "BB"? bbmiddle : bandType == "KC"? kcmiddle : dcmiddle

// uPlot = plot(displayBands? upper: na, title="Upper", color=color.new(color.green, cloudTransparency))
// lPlot = plot(displayBands? lower: na, title="Lower", color=color.new(color.red, cloudTransparency))
// mPlot = plot(displayBands? middle: na, title="Middle", color=color.new(color.blue, cloudTransparency))

// fill(uPlot, mPlot, title='UpperRange', color=color.new(color.green, cloudTransparency))
// fill(lPlot, mPlot, title='LowerRange', color=color.new(color.red, cloudTransparency))
//************************************ bandwidth *************************************************** //
_bbw = bbw(bmasource, bmatype, bmalength, multiplier, sticky=bsticky)
_kcw = kcw(bmasource, bmatype, bmalength, multiplier, useTrueRange, sticky=bsticky)
_dcw = dcw(bmalength, useAlternateSource, bmasource, sticky=bsticky)

_bandwidth = bandType == "BB"? _bbw : bandType == "KC"? _kcw : _dcw
_displayBandwidth = display == "bandwidth" or (display == "all" and nonOverlay)
// plot(_displayBandwidth? _bandwidth: na, title="Bandwidth", color=color.maroon)

//************************************ bandpercent *************************************************** //
_bpercentb = bpercentb(bmasource, bmatype, bmalength, multiplier, sticky=bsticky)
_kpercentk = kpercentk(bmasource, bmatype, bmalength, multiplier, useTrueRange, sticky=bsticky)
_dpercentd = dpercentd(bmalength, useAlternateSource, bmasource, sticky=bsticky)

_bandpercent = bandType == "BB"? _bpercentb : bandType == "KC"? _kpercentk : _dpercentd
_displayBandPercent = display == "bandpercent" or (display == "all" and nonOverlay)
// plot(_displayBandPercent? _bandpercent: na, title="BandPercent", color=color.fuchsia)

//************************************ Oscillators *************************************************** //
oscType = input.string("cci", title="Oscillator Type", group="Oscillator", options=["cci", "cmo", "cog", "mfi", "roc", "rsi", "stoch", "tsi", "wpr"])
oLength = input.int(14, title="Length", group="Oscillator")
shortLength = input.int(9, title="Short Length (TSI)", group="Oscillator")
longLength = input.int(9, title="Long Length (TSI)", group="Oscillator")
method = input.string("highlow", title="Dynamic Overvought/Oversold Calculation method", group="Oscillator", options=["highlow", "sma", "ema", "hma", "rma", "wma", "vwma", "swma", "linreg", "median"])
highlowlength = input.int(50, title="Length", group="Oscillator")
osticky = input.bool(true, title="Sticky", group="Oscillator")
[_oscillator, _overbought, _oversold] = oscillator(oscType, oLength, shortLength, longLength, method = method, highlowLength=highlowlength, sticky=osticky)

// Just using oscillatorRange with only oscillator input
// [newUpper, newLower] = oscillatorRange(oscillator, method, highlowlength, oLength, osticky)
_displayOscillator = display == "oscillator" or (display == "all" and nonOverlay)
// plot(_displayOscillator? _oscillator: na, title="Oscillator", color=color.blue)
// plot(_displayOscillator? _overbought: na, title="Overbought", color=color.red)
// plot(_displayOscillator? _oversold: na, title="Oversold", color=color.green)

bands = multibands()
_displayMultibands = (display == "multibands" or (display == "all" and overlay)) and array.size(bands) == 15
// plot(_displayMultibands? array.get(bands, 0): na, title="L7", color=color.red)
// plot(_displayMultibands? array.get(bands, 1): na, title="L6", color=color.red)
// plot(_displayMultibands? array.get(bands, 2): na, title="L5", color=color.red)
// plot(_displayMultibands? array.get(bands, 3): na, title="L4", color=color.red)
// plot(_displayMultibands? array.get(bands, 4): na, title="L3", color=color.red)
// plot(_displayMultibands? array.get(bands, 5): na, title="L2", color=color.red)
// plot(_displayMultibands? array.get(bands, 6): na, title="L1", color=color.red)
// plot(_displayMultibands? array.get(bands, 7): na, title="M", color=color.blue)
// plot(_displayMultibands? array.get(bands, 8): na, title="U1", color=color.green)
// plot(_displayMultibands? array.get(bands, 9): na, title="U2", color=color.green)
// plot(_displayMultibands? array.get(bands, 10): na, title="U3", color=color.green)
// plot(_displayMultibands? array.get(bands, 11): na, title="U4", color=color.green)
// plot(_displayMultibands? array.get(bands, 12): na, title="U5", color=color.green)
// plot(_displayMultibands? array.get(bands, 13): na, title="U6", color=color.green)
// plot(_displayMultibands? array.get(bands, 14): na, title="U7", color=color.green)


length = input.int(5, 'Length', step=5, group='Zigzag')

displayTooltip = 'REGULAR : green bars for upswing and red bars for downswing volume. Moiving average can be applied to this type of display\n\n'+
                     'PLUS/MINUS - STACKED : both upswing and downswing will have positive and negative volumne bars stacked on each other. If the first bar is green or red depends on stacking style\n\n'+
                     'PLUS/MINUS - OVERLAPPING : both positive and negative volume bars are shown. But, both starts from zero and overlaps each other.\n\n'+
                     'PLUS/MINUS - OPPOSITE SIDES : positive volume is shown from 0 to upside whereas negative volume bars are shown from 0 to downwards\n'
displayType = input.string('regular', 'Bar Style', options=['regular', 'plus/minus - stacked', 'plus/minus - overlapping', 'plus/minus - opposite sides'], group='Display', tooltip=displayTooltip)

stackingTooltop = 'DIRECTION-BASED : Up volume(green) bar is placed first on upswing and down volume(red) bar is placed. first on downswing\n\n'+
                     'GREEN-FIRST : Up volume(green) bar is always placed first\n\n'+
                     'RED-FIRST : Down volume(red) bar is always placed first\n\n'+
                     'HIGHEST-FIRST : Bar with highest portion of volume is placed first\n\n'+
                     'LOWEST-FIRST : Bar with lowest portion of volume is placed first'
stackedStyle = input.string('direction-based', 'Stack Style', options=['direction-based', 'green-first', 'red-first', 'highest-first', 'lowest-first'], group='Display', tooltip=stackingTooltop)

//Ma is only applicable for few display styles
applyMa = input.bool(true, 'Show MA', group='Moving Average', inline='ma')
maType = input.string('sma', '', options=["sma", "ema", "hma", "rma", "wma"], group='Moving Average', inline='ma')
maLength = input.int(20, '', step=10, group='Moving Average', inline='ma', tooltip='Moving average is applied only for display types - REGULAR, PLUS/MINUS - OPPOSITE SIDES')

//Volume plot style - boolean flags
plotDifferentialVolume = displayType != 'regular'
plotOnDifferentSides = displayType == 'plus/minus - opposite sides'
overlap = displayType == 'plus/minus - overlapping'
stacked = displayType == 'plus/minus - stacked'
displayMaRegular = applyMa and not plotDifferentialVolume
displayMaBiDirectional = applyMa and plotDifferentialVolume and plotOnDifferentSides

//Stacking style if plot style is stacked bars
directionalStacking = stackedStyle == 'direction-based'
greenFirst = stackedStyle == 'green-first'
redFirst = stackedStyle == 'red-first'
highestFirst = stackedStyle == 'highest-first'
lowestFirst = stackedStyle == 'lowest-first'

[zigzagpivots, zigzagpivotbars, zigzagpivotdirs, _, _, _, _, _, _, newPivot, doublePivot] = czigzag(length,20,h_i_g_h,l_o_w,h_i_g_h,l_o_w)
var volumeArray = array.new_float()
var uVolumeArray = array.new_float()
var lVolumeArray = array.new_float()
var int lastBar = na
if(array.size(zigzagpivots)>1)
    currentBar = array.get(zigzagpivotbars, 0)
    lastBar := array.get(zigzagpivotbars, 1)

    currentDir = array.get(zigzagpivotdirs, 0)
    
    zvolumeplus = 0.0
    zvolumeminus = 0.0
    for i=lastBar==currentBar? na : lastBar+1 to currentBar-1
        zvolumeminus += (o_p_e_n[bar_index-i] > c_l_o_s_e[bar_index-i] ? v_o_l_u_m_e[bar_index-i] : 0)
        zvolumeplus += (o_p_e_n[bar_index-i] > c_l_o_s_e[bar_index-i] ? 0 : v_o_l_u_m_e[bar_index-i])

    zvolumeminus += (o_p_e_n[bar_index-currentBar] > c_l_o_s_e[bar_index-currentBar] ? v_o_l_u_m_e[bar_index-currentBar] : 0)
    zvolumeplus += (o_p_e_n[bar_index-currentBar] > c_l_o_s_e[bar_index-currentBar] ? 0 : v_o_l_u_m_e[bar_index-currentBar])
    
    zvolumeminus += (o_p_e_n[bar_index-lastBar] > c_l_o_s_e[bar_index-lastBar] ? v_o_l_u_m_e[bar_index-lastBar] : 0)
    zvolumeplus += (o_p_e_n[bar_index-lastBar] > c_l_o_s_e[bar_index-lastBar] ? 0 : v_o_l_u_m_e[bar_index-lastBar])
    zvolume = zvolumeplus + zvolumeminus

    zvolumeminus := plotOnDifferentSides? -zvolumeminus : zvolumeminus
    if(plotDifferentialVolume)
        var box ubar = na
        var box lbar = na
        if(lastBar == lastBar[1] and currentBar != lastBar)
            box.delete(ubar)
            box.delete(lbar)
            array.shift(uVolumeArray)
            array.shift(lVolumeArray)
        else
            box.set_right(ubar, lastBar)
            box.set_right(lbar, lastBar)
            box.set_bgcolor(ubar, color.new(color.green, 70))
            box.set_bgcolor(lbar, color.new(color.red, 70))
        
        uStart = plotOnDifferentSides or overlap? 0 :
                     directionalStacking? (currentDir > 0? 0 : zvolumeminus) :
                     greenFirst ? 0 : redFirst ? zvolumeminus : 
                     highestFirst ? (zvolumeplus > zvolumeminus ? 0 : zvolumeminus) : 
                     lowestFirst ? (zvolumeplus > zvolumeminus ? zvolumeminus : 0) : na
        
        uEnd = uStart + zvolumeplus
        
        lStart = plotOnDifferentSides or overlap? 0 :
                     directionalStacking? (currentDir > 0? zvolumeplus : 0) :
                     greenFirst ? zvolumeplus : redFirst ? 0 : 
                     highestFirst ? (zvolumeplus > zvolumeminus ? zvolumeplus : 0) : 
                     lowestFirst ? (zvolumeplus > zvolumeminus ? 0 : zvolumeplus) : na
        lEnd = lStart + zvolumeminus
        
        ubar := box.new(left=lastBar, top=uEnd, right=currentBar, bottom=uStart, bgcolor = color.new(color.green, 20))
        pa.unshift(uVolumeArray, zvolumeplus, maLength)

        lbar := box.new(left=lastBar, top=lEnd, right=currentBar, bottom=lStart, bgcolor = color.new(color.red, 20))
        pa.unshift(lVolumeArray, zvolumeminus, maLength)
    else
        var box vbar = na
        barColor = currentDir>0? color.green: color.red
        if(lastBar == lastBar[1] and currentBar != lastBar)
            box.delete(vbar)
            array.shift(volumeArray)
        else
            box.set_right(vbar, lastBar)
            box.set_bgcolor(vbar, color.new(barColor[1], 70))
        vbar := box.new(left=lastBar, top=zvolume, right=currentBar, bottom=0, bgcolor = color.new(barColor, 20))
        pa.unshift(volumeArray, zvolume, maLength)
vma = pa.ma(volumeArray, maType, maLength)
vmaPlus = pa.ma(uVolumeArray, maType, maLength)
vmaMinus = pa.ma(lVolumeArray, maType, maLength)

plot(displayMaRegular?vma:na, 'Volume moving average')
plot(displayMaBiDirectional?vmaPlus:na, 'Plus Volume moving average', color=color.green)
plot(displayMaBiDirectional?vmaMinus:na, 'Minus Volume moving average', color=color.red)
